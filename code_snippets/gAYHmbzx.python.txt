# LEAK BY SYS | SYSS.EU.ORG
import os
import discord
import keep_alive
import random, string
import asyncio
import time
Â 
from discord import Color
from discord.ext import commands
from random import randrange
from time import sleep
Â 
client = commands.Bot(command_prefix = "w?")
client.help_command = commands.MinimalHelpCommand()
Â 
Â 
#help command
class HelpCommand(commands.MinimalHelpCommand):
Â  async def send_pages(self):
Â  Â  destination = self.get_destination()
Â  Â  e = discord.Embed(description='')
Â  Â  for page in self.paginator.pages:
Â  Â  Â  e.description += page
Â  Â  await destination.send(embed=e)
Â 
client.help_command = HelpCommand()
Â 
#dms a welcome message everytime a user joins a server the bot is in, uhh maybe?
@client.event
async def on_member_join(member):
Â  Â  await member.create_dm()
Â  Â  await member.dm_channel.send(f"ğŸ‘‹Hello! {member.name}, Thanks for joining {client.guild}. Make sure to be active and check out our channels! ")
Â 
async def on_message(ctx):
Â  if (ctx.author.id == ""):
Â  Â  return None
Â  await client.process_commands(ctx)
Â 
Â 
@client.command()
async def ttd(message):
Â  await message.reply("Please type the message that you want to send to the devs [BETA cmd]")
Â  ttdinpsys = (await client.wait_for('message'))
Â  ttdinpcont = ttdinpsys.content
Â  print(ttdinpcont + "\n")
Â  print(f"User ID: {message.author.id}")
Â  ttdreply = input()
Â  await message.reply(f"Reply from devs: {ttdreply}")
Â  print(f"ğŸ“ | {message.author.name} used speak and asked {ttdinpcont} and devs responded with {ttdreply}")
Â  Â  
#watching [n] members thing
@client.event
async def on_ready():
Â  members = 0
Â  for guild in client.guilds:
Â  Â  members += guild.member_count - 1
Â  await client.change_presence(activity=discord.Activity (type=discord.ActivityType.watching, name=f"{members} users in {len(client.guilds)} servers! | ğŸ‡ºğŸ‡¦"))
Â  print(f"âš™ï¸ | Bot is running")
Â 
Â  
@client.command()
async def rps(message):
Â  rpsmat=["rock", "paper", "scissors"]
Â  ranmat=random.choice(rpsmat)
Â  embed = discord.Embed(description='**Start the game by choosing one of the following**:\n\n:rock: `Type "rock"` to choose rock,\n:page_facing_up: `Type "paper"` to choose paper,\n:scissors:\nType `"scissors"` to choose scissors.\n\n:alarm_clock: **You have 5 seconds**')
Â  await message.send(embed=embed)
Â  
Â  userchoI = (await client.wait_for('message'))
Â  usercho = userchoI.content
Â  time.sleep(10)
Â  if usercho == "rock":
Â  Â  if ranmat == "rock":
Â  Â  Â  await message.send("Its a tie since I also chose rock!")
Â  Â  elif ranmat == "paper":
Â  Â  Â  await message.send("Sorry, you lost since i chose paper :(")
Â  Â  elif ranmat == "scissors":
Â  Â  Â  await message.send("You won since i chose scissors")
Â  Â  else:
Â  Â  Â  await message.send("Sorry, An error has occured, please run the command again.") Â  
Â  
Â  elif usercho == "paper":
Â  Â  if ranmat == "paper":
Â  Â  Â  await message.send("Its a tie since I also chose paper!")
Â  Â  elif ranmat == "scissors":
Â  Â  Â  await message.send("Sorry, you lost since i chose scissors :(")
Â  Â  elif ranmat == "rock":
Â  Â  Â  await message.send("You won since i chose rock!")
Â  Â  else:
Â  Â  Â  await message.send("Sorry, An error has occured, please run the command again.")
Â 
Â  elif usercho == "scissors":
Â  Â  if ranmat == "scissor":
Â  Â  Â  await message.send("Its a tie since I also chose scissors!")
Â  Â  elif ranmat == "rock":
Â  Â  Â  await message.send("Sorry, you lost since i chose rock :(")
Â  Â  elif ranmat == "paper":
Â  Â  Â  await message.send("You won since i chose paper!")
Â  Â  else:
Â  Â  Â  await message.send("Sorry, An error has occured, please run the command again.")
Â  else:
Â  Â  await message.send("Invalid Option.")
Â  print(f"ğŸ“ | {message.author.name} Used rps and chose {usercho} and bot chose {ranmat}")
Â  
Â  Â  Â  
Â  Â  
Â  Â  
@client.command()
async def ping(ctx):
Â  latency = client.latency
Â  embed = discord.Embed(title=f'PongğŸ“! Latency is **{latency}** second(s)')
Â  await ctx.send(embed=embed)
Â  print(f" ğŸ“ | {ctx.author.name} used ping to see how fast da bot is going aaa")
Â  
@client.command()
async def amongus(ctx):
Â  mogusch = ["You are a crewmate!", "You are a crewmate, and won the game!", "You are da sus imposter, unfortunately, you got ejected :c", "You are da sus impostor, and you won the game!", "You are a crewmate, but you were next to a dead body and then got ejected :c", f"You are {ctx.author.name}!"]
Â  mogus = random.choice(mogusch)
Â  await ctx.send(mogus)
Â  print(f"ğŸ“ | {ctx.author.name} felt sus enough that he used amongus and got {mogus}")
Â 
@client.command()
async def hello(ctx):
Â  await ctx.send("hi")
Â  print(f"ğŸ“ | {ctx.author.name} used hi")
Â 
Â 
Â 
Â 
Â 
Â 
Â 
#disgame cmd
@client.command()
async def disgame(ctx):
Â  await ctx.reply("Note: This generator mostly contains invalid links. Why? Well the generator is randomized and we cant fix this at this time.\nLink: https://ptb.discord.com/store/skus/" + ''.join(random.choice(string.digits) for _ in range(18)))
Â  print(f"ğŸ“ | {ctx.author.name} used disgame") 
Â  
Â 
Â 
Â  
Â 
#diceroll cmd
@client.command()
async def diceroll(ctx):
Â  embed = discord.Embed(title="The dice is rolling...", color=Color.blue())
Â  await ctx.send(embed=embed) ; sleep(5.0)
Â  dicenums=["1", "2", "3", "4", "5", "6"]
Â  dicelanded=random.choice(dicenums)
Â  embed = discord.Embed(title=f"The dice has landed on {dicelanded}!", color=Color.green())
Â  await ctx.send(embed=embed) ; sleep(5.0)
Â  print(f"ğŸ“ | {ctx.author.name} used diceroll")
Â  
Â 
Â 
Â 
#version cmd
@client.command()
async def version(ctx):
Â  await ctx.reply("WottBot Version 1.1.9")
Â  print(f"ğŸ“ | {ctx.author.name} used version")
Â  
Â  
Â 
#coinflip cmd
@client.command()
async def coinflip(ctx):
Â  cfchoices = ["Heads", "Tails"]
Â  await ctx.send(random.choice(cfchoices))
Â  print(f"ğŸ“ | {ctx.author.name} used coinflip")
Â  
Â 
Â 
#clear cmd
@client.command()
@commands.has_permissions(manage_messages=True)
async def clear(ctx, amount : int):
Â  authorperms = ctx.author.permissions_in(ctx.channel)
Â  if authorperms.manage_messages:
Â  Â  await ctx.channel.purge(limit=amount+1)
Â  Â  embed = discord.Embed(title=f"{ctx.author.name} cleared: {ctx.channel.name}", description="lol")
Â  Â  print(f"{ctx.author.name} Cleared #{ctx.channel.name}, Server name:{ctx.guild.name}")
Â  Â  await ctx.send(embed=embed)
Â  else:
Â  Â  await ctx.send("I'm sorry but you, yes you dont have permission to delete messages!")
Â  print(f"ğŸ“ | {ctx.author.name} used clear")
Â  
Â 
#credit cmd
@client.command()
async def credit(ctx):
Â  embed = discord.Embed(title="\n**Credits**\n> **wott#6277**\nMain developer of wottbot, Most of the commands are made by wott\n\n> **SLT WorldğŸ‡¹ğŸ‡¼#3293**\nAnother Developer who is a bot developer and c# game developer who checks and fixes the bot if a problem occurs\n\n")
Â  await ctx.reply(embed=embed)
Â  print(f"ğŸ“ | {ctx.author.name} used credit")
Â  
Â 
#invalid command error
@client.event
async def on_command_error(ctx, error):
Â  Â  if isinstance(error, commands.CommandNotFound):
Â  Â  Â  await ctx.send("Invalid command")
Â  Â  
Â  
Â 
Â 
Â  
Â  
Â 
Â 
my_secret = os.environ['beanz']
keep_alive.keep_alive()
client.run(my_secret)