/* Plugin generated by AMXX-Studio */
 
#include <amxmodx>
#include <amxmisc>
#include <cstrike>
#include <hamsandwich>
#include <fakemeta>
#include <fun>
#include <engine>
#include <xs>
#include <fun>
#include <fvault>
 
 
#pragma tabsize 0
#pragma compress 1
 
#define CHAT_TAG "^3[^4KnifeDuels^3]^1 " // add a space right after if you want one between the tag and the messages
 
#define DUEL_COMMAND "/duel" // this is the word used to start duel
#define TOGGLE_COMMAND "/offduel" // this is the word used to go online or offline
#define GIVEUP_COMMAND "/giveup" // this is the word used to end the duel
 
#define ARENA_ENT_NAME "entity_arena" // this is the arena's entity name
 
// here you can set the maximum number of arenas that can be used ingame
#define MAX_ARENAS 4
 
 
new const arena_names[][] = {
    "",
    "A",    
    "B",    
    "C",     
    "D"
}
 
// some arena codes...
#define ARENA_CODE 305924
#define FAKE_CODE 6969696969
#define CENTER_CODE 9696969696
#define EXTRA_CODE 911911911
 
// task code for advert
#define TASK_AD 34585029
 
// some movement defines
#define MOVE_UP 0
#define MOVE_DOWN 1
#define MOVE_RIGHT 2
#define MOVE_LEFT 3
#define MOVE_FRONT 4
#define MOVE_BACK 5
 
// Arena ground size
#define ARENA_MINS Float:{-380.0, -250.0, -10.0}
#define ARENA_MAXS Float:{380.0, 250.0, 1.0}
 
#define BRIDGE_MINS Float:{-350.0, -10.0, 0.0}
#define BRITGE_MAXS Float:{350.0, 10.0, 10.0}
 
#define BOX_MINS Float:{-35.0, -35.0, -40.0}
#define BOX_MAXS Float:{35.0, 35.0, 40.0}
 
// arena coords offcourse, this is used to build the arena.
new const Float:ARENA_COORDS[][2] = { 
    {0.0,0.0}
}
 
new const Float:BOX_COORDS[][2] = { 
    {130.0,0.0},
    {-130.0,0.0},
    {130.0,100.0},
    {-130.0,-100.0},
    {130.0,-100.0},
    {-130.0,100.0}
    
}
 
enum {
    BLUE_SIDE = 0,
    RED_SIDE = 1,
    LEFT_SIDE = 2,
    RIGHT_SIDE = 3,
    TOP_SIDE = 4
}
 
new const ARENA_FILE[] = "%s/duel_arena/%s.cfg"
 
// if you want to disable a sound, rename it with "common/null.wav"
new const DUEL_SOUNDS[][] = {
    "ambience/goal_1.wav",       // 0 round win
    "x/nih_die2.wav",       // 1 round lose
    "ambience/des_wind1.wav",   // 2 round draw
    "buttons/bell1.wav",         // 3 round start
    "buttons/blip1.wav" ,    // 4 accepted duel
    "common/null.wav",  // 5 Countdown
    "common/null.wav"   // 6 "Go!"
}
 
new const ARENA_MODELS[][] = {
    "models/Duel/Duel_Platform.mdl", // Arena's ground
    "models/Duel/Duel_Platform.mdl" // Arena's walls
}
 
new const BRIDGE_MODELS[][] = 
{
    "models/Duel/Duel_Bridge.mdl", // Arena's ground
    "models/Duel/Duel_Bridge.mdl" // Arena's walls
}
 
new const BOX_MODELS[][] = {
    "models/Duel/Duel_Box.mdl", // Arena's ground
    "models/Duel/Duel_Box.mdl" // Arena's walls
}
 
new const MAP_FIX[][] = {
    "ka_acer_2"
}
 
new Float:MAP_FIX_Z_COORD[] = {
    -864.253723
}
 
new Head_shot[33][33]
new fakes;
new is_in_duel[33],his_countdown[33],is_frozen[33],his_challenger[33],his_asker[33],arena_number[33],his_wins[33],his_name[33][64];
new rounds[MAX_ARENAS+1],Float:arena_coord[MAX_ARENAS+1][3]; // using +1 just incase...
new got_spawn[33],Float:his_original_spawn[33][3];
new next_empty_arena,total_arenas;
new MAXPLAYERS,map_name[48]
new cvar_z_fix,cvar_sounds,cvar_rounds,cvar_kills,cvar_cooldown,cvar_time;
new Float:max_size[3],Float:min_size[3];
new selected = 1,Float:move_size[33],his_timer[33],his_offline[33],his_HS[33];
new map_default_hp;
new map_id = -1;
new his_previous_team[33];
// using these for less cpu usage.
new IS_BUGGED_MAP = 0,MAP_FIX_ENABLED,SOUNDS_ENABLED,MAX_ROUNDS,MAX_KILLS,MAX_COUNTDOWN,MAX_TIME;
new Float:his_player_spawn[33][3],Float:his_player_angle[33][3];
 
#define P_NAME "Knife Duels"
#define P_VERS "1.0"
#define P_AUTH "raizo"
#define P_REQ "Knife Server"
new killed_forward;
 
/////////////////////////////////  Invisible  //////////////////////////////////////////////////////
enum groups ( <<= 1 )
{
    GROUP_NONE,
    GROUP_ENTITY = 1,
    GROUP_PLAYER
}
 
new p_Transparency
new g_PlayerSolid[33]
new bool:his_arena_entity[1386];
new bool:his_player_arena_entity[33];
new arena_selected;
new prevent_bad_spawn[33];
///////////////////////////////////  Menu  ////////////////////////////////////////////////////////
 
#define MAX_WAYS 32
 
enum menu_arenas
{
    platform = 1,
    britge
}
 
enum menu_types
{
    Both = 1,
    Stab,
    Slash,
    Headshot,
    Nonstop,
    Weapons
}
 
enum principal_config
{
    menu_arenas:swich_arena,
    menu_types:swich_types
}
 
new principals[MAX_WAYS+1][principal_config]    
new szTmp[192];
new his_arena[33] = 0
new his_types[33] = 0
 
#define Max_Weapons_Names 18
 
 
new WeaponName[][] =
{
    "\r[\dNone\r]",
    "\r[\yAK47\r]",
    "\r[\yM4A1\r]",
    "\r[\yAWP\r]",
    "\r[\yDEAGLE\r]",
    "\r[\ySCOUT\r]",
    "\r[\yXM1014\r]",
    "\r[\yMAC10\r]",
    "\r[\yAUG\r]",
    "\r[\yUMP45\r]",
    "\r[\ySG550\r]",
    "\r[\yGALIL\r]",
    "\r[\yFAMAS\r]",
    "\r[\yMP5 NAVY\r]",
    "\r[\yM249\r]",
    "\r[\yM3\r]",
    "\r[\yG3SG\r]",
    "\r[\ySG552\r]",
    "\r[\yP90\r]"
};
new WeaponModel[][] =
{
    "weapon_knife",
    "weapon_ak47",
    "weapon_m4a1",
    "weapon_awp",
    "weapon_deagle",
    "weapon_scout",
    "weapon_xm1014",
    "weapon_mac10",
    "weapon_aug",
    "weapon_ump45",
    "weapon_sg550",
    "weapon_galil",
    "weapon_famas",
    "weapon_mp5navy",
    "weapon_m249",
    "weapon_m3",
    "weapon_g3sg1",
    "weapon_sg552",
    "weapon_p90"
};
 
new Weapons_Settings[19];
new display_hud
new HamHook:fw_TraceAttack;
new Float:fVelocity[3]
 
_Un_RegisterHamForwards(on = 0)
{
on ? EnableHamForward(fw_TraceAttack) : DisableHamForward(fw_TraceAttack);
}
 
new bool:isBlocked[ 33 ][ 33 ]
 
new CSW_MAXAMMO[33]= {-2, 52, 0, 90, 1, 32, 1, 100, 90, 1, 120, 100, 100, 90, 90, 90, 100, 120, 30, 120, 200, 32, 90, 120, 90, 2, 35, 90, 90, 0, 100, -1, -1}
 
//////////////////////////////////////////////////////////
 
enum _:RankData
{
    Rank_Kills,
    Rank_Name[ 32 ],
    Rank_SteamID[ 35 ]
};
 
new const g_szVaultName[ ] = "Knife_Duels_Rank";
 
new pCvar_Top;
///////////////////////////////////////////////////////////
 
 
public plugin_init()
{
    register_plugin(P_NAME, P_VERS, P_AUTH)
    
         register_forward(FM_AddToFullPack,"ForwardAddToFullPack",1)
         register_forward(FM_AddToFullPack,"ForwardAddToFullPackPost",1);
         register_forward(FM_PlayerPreThink,"ForwardPlayerPreThink")
         register_forward(FM_PlayerPostThink,"ForwardPlayerPostThink")
         register_forward(FM_TraceLine,"ForwardTraceLine",1)
         register_forward(FM_TraceHull,"ForwardTraceHull",1)
         register_forward(FM_PlayerPreThink,"fw_PlayerPreThink")
         register_forward(FM_CmdStart,"Rush_Non_Stop");
    register_forward( FM_CmdStart , "Cmd_start" );
    register_forward(FM_SetModel, "Fw_SetModel")
    register_forward(FM_UpdateClientData, "block_moving", 1)
    
         RegisterHam(Ham_Spawn, "player", "OnCBasePlayer_Spawn_Post", true);
    RegisterHam(Ham_Killed, "player", "Player_Killed")
    RegisterHam(Ham_TakeDamage, "player", "Player_Take_Damage", 0)
    RegisterHam(Ham_Spawn,"player","Player_spawn_post",1)
         RegisterHam(Ham_TraceAttack, "player", "Ham_TraceAttack_player", 1)
         RegisterHam(Ham_Player_PreThink, "player", "fwd_Player_PreThink");
     
    register_event("HLTV","round_start_event", "a", "1=0", "2=0")
    register_event("CurWeapon", "event_curweapon", "be", "1=1")
    register_touch(ARENA_ENT_NAME, "player", "forward_touch");
    RegisterHam(Ham_Touch, "weaponbox", "HAM_Touch_Weapon");
     
    fw_TraceAttack = RegisterHam(Ham_TraceAttack, "player", "Forward_TraceAttack");
    killed_forward = CreateMultiForward("duel_player_killed", ET_IGNORE, FP_CELL,FP_CELL);
    
    register_clcmd("say","say_hook")
    register_clcmd("say_team","say_hook")
    register_clcmd("say /origin","print_coords")
    register_clcmd("say /kdc","Principal_Menu")
    
    register_clcmd("say /arena","editor_menu")
 
    cvar_z_fix = register_cvar("gld_z_map_fix","0")
    cvar_sounds = register_cvar("gld_sounds","1")
    cvar_rounds =register_cvar("gld_rounds","20")
    cvar_kills =register_cvar("gld_kills","10")
    cvar_cooldown = register_cvar("gld_cooldown","1")
    cvar_time = register_cvar("gld_max_nokill_time","60")
         p_Transparency = register_cvar("amx_duel_transparency","0")
    display_hud = register_cvar("amx_hs_display", "1")
    
    MAXPLAYERS = get_maxplayers();
 
    
    get_mapname(map_name,charsmax(map_name))
    new size = sizeof(MAP_FIX)
    for(new i; i <size;i++)
    {
        if(equal(map_name,MAP_FIX[i]))
        {
            map_id = i
            IS_BUGGED_MAP = 1
        }
    }
    if(containi(map_name,"35hp") != -1)
        map_default_hp = 35
    else if(containi(map_name,"1hp") != -1)
        map_default_hp = 1
    else map_default_hp = 100
    load_arena_coords(-1)
    
    new cfgdir[32], urlfile[64]
    get_configsdir(cfgdir, charsmax(cfgdir))
    formatex(urlfile, charsmax(urlfile), "%s/duel_arena", cfgdir)
    if(!dir_exists(urlfile))
    {
        mkdir(urlfile)
        server_print("%sCreated new folder: %s",CHAT_TAG,urlfile)
    }
    update_cvars()
    
    set_task(10.0,"Advertise",TASK_AD)
    
 
         register_srvcmd( "reset_duel_rank", "CmdReset" );
    
         register_clcmd( "say /drank", "CmdRank" );
         register_clcmd( "say /dtop", "CmdTop" );
    
         RegisterHam(Ham_Killed, "player", "fw_PlayerKilled", 1);
    
         pCvar_Top = register_cvar( "amx_duels_top", "15" ); 
    
}
 
////////////////////////////////////////////  MENU  ////////////////////////////////////////////////
public Principal_Menu(id)
{
    new menu = menu_create("\r[\y Duel Menu \r]\w By raizo","Peincipal_Menu_Handled")
 
    if(is_in_duel[id] == 2)
    {
        client_print(id,print_chat,"You have no access to duel menu!")
        return PLUGIN_HANDLED;
    }
        
 
    formatex(szTmp,charsmax(szTmp),"Select Player");
    menu_additem(menu,szTmp,"1")
 
    if(his_types[id] == 4)
    {
        formatex(szTmp,charsmax(szTmp),"\wAuto Selected \r[\yBritge Arena\r]");
        menu_additem(menu,szTmp,"2")    
    }
    else if(Weapons_Settings[id] >= 1)
    {
        formatex(szTmp,charsmax(szTmp),"\wAuto Selected \r[\yWeapons Arena\r]");
        menu_additem(menu,szTmp,"2")    
    }
    else
    {
        formatex(szTmp,charsmax(szTmp),"Choose Arena \y%s",arenas_results(principals[id][swich_arena]));
        menu_additem(menu,szTmp,"2")
    }
    if(his_types[id] == 5)
    {
        formatex(szTmp,charsmax(szTmp),"Battle Types \y%s", WeaponName[Weapons_Settings[id]]);
        menu_additem(menu,szTmp,"3")
    }
    else
    {
        formatex(szTmp,charsmax(szTmp),"Battle Types \y%s", types_results(principals[id][swich_types]));
        menu_additem(menu,szTmp,"3")
    }
    
    formatex(szTmp,charsmax(szTmp),"Appear in list %s",his_offline[id] ?"\y[Enabled]":"\r[Disabled]");
    menu_additem(menu,szTmp,"4")
    
    if(his_offline[id] == 1)
    {
        menu_addtext(menu, "\dYou cannot receive & send duel requests", 1);
    }
    
    formatex(szTmp,charsmax(szTmp),"Block Player Menu");
    menu_additem(menu,szTmp,"5")
    
    formatex(szTmp,charsmax(szTmp),"Rank & Top 15");
    menu_additem(menu,szTmp,"6")
    
    menu_display(id,menu)
 
    return PLUGIN_HANDLED;
}
 
public Peincipal_Menu_Handled(id,menu,item)
{
    if(item == MENU_EXIT)
    {
        menu_destroy(menu);
 
        return PLUGIN_HANDLED;
    }
 
    new data[3], iName[64]
    new access, callback;
    menu_item_getinfo(menu, item, access, data,2, iName, 63, callback);
    new key = str_to_num(data)
 
    switch(key)
    {
        case 1:
        {
            duel_players_list(id)
            return PLUGIN_HANDLED;
        }
        case 2:
        {
            principals[id][swich_arena] = ( ++principals[id][swich_arena] > (menu_arenas:2) ) ? (menu_arenas:1) :principals[id][swich_arena]
        }
        case 3:
        {
            principals[id][swich_types] = ( ++principals[id][swich_types] > (menu_types:6) ) ? (menu_types:1) :principals[id][swich_types]
        }
        case 4:
        {
            toggle_offline(id)
        }
        case 5:
        {
            BlockMenu(id)
       return PLUGIN_HANDLED;
        }
        case 6:
        {
            Rank_Menu(id)
       return PLUGIN_HANDLED;
        }
    }
    menu_destroy(menu);
 
    Principal_Menu(id)
    bot(id)
    return PLUGIN_HANDLED;
}
 
public bot(id)
{
    if(is_user_connected(id))
    {
        arenas_handled(id)
        types_handled(id)
    }
}
 
arenas_results(menu_arenas:part)
{
    new szResult[64]
    
    switch(part)
    {
        case platform:copy(szResult, charsmax(szResult), "Platform Arena");
        case britge:copy(szResult, charsmax(szResult), "Britge Arena");
   
        default:copy(szResult, charsmax(szResult), "[Not Selected]");
    }
    return szResult;
}
 
 
 
types_results(menu_types:part)
{
    new szResult[64]
    
    switch(part)
    {
        case Both:copy(szResult, charsmax(szResult), "Stab & Slash");
        case Slash:copy(szResult, charsmax(szResult), "Slash");
        case Stab:copy(szResult, charsmax(szResult), "Stab");
        case Headshot:copy(szResult, charsmax(szResult), "Headshot");
        case Nonstop:copy(szResult, charsmax(szResult), "Non Stop [Rush Arena]");
        case Weapons:copy(szResult, charsmax(szResult), "Weapons Arena");
   
        default:copy(szResult, charsmax(szResult), "[Not Selected]");
    }
    return szResult;
}
 
 
 
types_handled(id)
{
    switch(principals[id][swich_arena]) 
    {
        case platform:
        {
            his_arena[id] = 0
        }
        case britge:
        {
            his_arena[id] = 1
        }
    }
    return 0;
}
 
arenas_handled(id)
{
    switch(principals[id][swich_types]) 
    {
        case Both:
        {
            his_types[id] = 0;
       Weapons_Settings[id] = 0;
        }
        case Stab:
        {
            his_types[id] = 2;
       Weapons_Settings[id] = 0;
        }
        case Slash:
        {
            his_types[id] = 1;
       Weapons_Settings[id] = 0;
        }
        case Headshot:
        {
            his_types[id] = 3;
       Weapons_Settings[id] = 0;
            _Un_RegisterHamForwards(display_hud);
        }
        case Nonstop:
        {
            his_types[id] = 4;
       his_arena[id] = 1;
       Weapons_Settings[id] = 0;
        }
        case Weapons:
        {
            his_types[id] = 5;
       KDC_WEAPONS_MENU(id)
       //return PLUGIN_HANDLED;
        }
    }
    return 0;
}
 
 
 
 
public KDC_WEAPONS_MENU(id)
{
    Weapons_Settings[id] = 0;
    
    new menu = menu_create("\y[\r Weapons Menu \y]\w By raizo", "KDC_WEAPONS_MENU_HANDLED");
 
    for( new i = 0 ; i <= Max_Weapons_Names ; i++ )
 
    menu_additem( menu, WeaponName[ i ]);
 
    menu_display(id, menu, 0 );
}
 
public KDC_WEAPONS_MENU_HANDLED(id, menu, item)
{
    Weapons_Settings[id] = item;
    
    KDC_SET_WEAPON_MODEL(id);
}
 
public KDC_SET_WEAPON_MODEL(id)
{
    if (is_user_alive(id))
    {
        if (!equal(WeaponModel[Weapons_Settings[id]], ""))
        {
            //client_print(id, 3, "You selected %s !", WeaponModel[Weapons_Settings[id]]);
       his_arena[id] = 2;
        }
    }
    Principal_Menu(id)
}
 
 
 
////////////////////////////////////////////////////////////////////////////////////////////////////
 
public plugin_natives()
{
    register_library("knife_duels")
    register_native("is_user_in_duel","_is_user_in_duel")
    register_native("is_user_dueling_user","_is_user_dueling_user")
}
 
public get_non_duelers_alive()
{
    new count = 0
    for(new id; id < MAXPLAYERS;id++)
    {
        if(is_user_connected(id))
        {
            if(is_user_alive(id) && !is_in_duel[id])
            {
                count++
            }
        }
    }
    return count
}
 
public _is_user_in_duel(plugin, iParams)
{
    new id = get_param(1)
    if(!is_user_connected(id))
        return PLUGIN_CONTINUE
    if(is_in_duel[id] == 2)
        return PLUGIN_HANDLED
    return PLUGIN_CONTINUE
}
 
public _is_user_dueling_user(plugin, iParams)
{
    new id = get_param(1)
    new enemy = get_param(2)
    if(!is_user_connected(id))
        return PLUGIN_CONTINUE
    if(!is_user_connected(enemy))
        return PLUGIN_CONTINUE
    if(is_in_duel[id] != 2 || is_in_duel[enemy] != 2)
        return PLUGIN_CONTINUE
    if(id == his_challenger[enemy] && enemy == his_challenger[id])
        return PLUGIN_HANDLED
    return PLUGIN_CONTINUE
}
 
public forward_touch(ent, id)
{
    if(!pev_valid(id))
        return;
    if(!pev_valid(ent))
        return;
    if(is_user_alive(id) && get_user_noclip(id))
        return;
    static class[32]
    pev(ent,pev_classname,class,charsmax(class));
    if(equal(class,ARENA_ENT_NAME))
    {
        if(is_user_alive(id))
        {
            if(is_player_stuck(id) && is_in_duel[id] != 2)
            {
                back_to_the_spawn(id)
            }
        }
        
    }
    return;
}
 
public Ham_TraceAttack_player(victim, attacker, Float:Damage, Float:Direction[3], ptr, Damagebits)
{
    if(is_user_connected(attacker) && is_user_connected(victim))
    {
        Head_shot[attacker][victim] = bool:( get_tr2(ptr, TR_iHitgroup) == 1 )
    }
}
 
public editor_menu(id)
{
    if(!is_user_connected(id))
        return PLUGIN_HANDLED
    new flags = get_user_flags(id)
    if(!(flags & ADMIN_RCON))
    {
        client_print(id,print_chat,"You have no access to this command")
        return PLUGIN_HANDLED
    }
    
    arena_selected = 0;
    
    new menu
    menu = menu_create( "\rArena spawner:", "Arenaspawner_handler" );
    
    new nameu[32];
    
    formatex(nameu,charsmax(nameu), "Add");
    menu_additem(menu, nameu, "", 0);
    formatex(nameu,charsmax(nameu), "Remove");
    menu_additem(menu, nameu, "", 0);
    formatex(nameu,charsmax(nameu), "Remove all");
    menu_additem(menu, nameu, "", 0);
    formatex(nameu,charsmax(nameu), "Select");
    menu_additem(menu, nameu, "", 0);
    formatex(nameu,charsmax(nameu), "Select all");
    menu_additem(menu, nameu, "", 0);
    formatex(nameu,charsmax(nameu), "Move");
    menu_additem(menu, nameu, "", 0);
    formatex(nameu,charsmax(nameu), "Save");
    menu_additem(menu, nameu, "", 0);
    formatex(nameu,charsmax(nameu), "Load");
    menu_additem(menu, nameu, "", 0);
    menu_display(id, menu, 0 );
    return PLUGIN_HANDLED
}
 
public Arenaspawner_handler( id, menu, item )
{
    if ( item == MENU_EXIT )
    {
        menu_destroy( menu );
        remove_the_fake_arena()
        arena_selected = 1;
        return PLUGIN_HANDLED;
    }
    
    new szData[6], szName[64];
    new _access, item_callback;
    menu_item_getinfo( menu, item, _access, szData,charsmax( szData ), szName,charsmax( szName ), item_callback );
    new arenas_found;
    arenas_found = fakes_count()
    if(equali(szName,"Add"))
    {
        if(next_fake_arena() != -1)
        {
            start_fake_build(id,-1)
            if(fakes_count())
            {
                if(selected > MAX_ARENAS || selected == -1)
                {
                    selected = 1
                    select_the_fake_arena(EXTRA_CODE+selected)
                }
            }
        } else client_print_color(id,"%s ^3Maximum arenas reached.^1",CHAT_TAG)
    }
    else if(equali(szName,"Remove"))
    {
        if(fakes_count())
        {
            if(selected > MAX_ARENAS || selected == -1)
                selected = 1
            delete_the_fake_arena(EXTRA_CODE+selected)
            if(fakes_count())
                next_selection()
        } else client_print_color(id, "%s ^3No arenas found.",CHAT_TAG)
    }
    else if(equali(szName,"Remove all"))
    {
        //remove_menu(id)
        remove_the_fake_arena() 
        client_print_color(id, "%s ^3All arenas removed.",CHAT_TAG)
    }
    else if(equali(szName,"Select"))
    {
        if(fakes_count())
        {
            next_selection()
        } else client_print_color(id, "%s ^3No arenas found.",CHAT_TAG)
    }
    else if(equali(szName,"Select all"))
    {
        if(fakes_count())
        {
            selected = -1
            select_the_fake_arena(EXTRA_CODE+selected)
        } else client_print_color(id, "%s ^3No arenas found.",CHAT_TAG)
    }
    else if(equali(szName,"Move"))
    {
        if(fakes_count())
        {
            if(selected > MAX_ARENAS)
                selected = 1
            select_the_fake_arena(EXTRA_CODE+selected)
            menu_destroy( menu );
            move_menu(id,EXTRA_CODE+selected)
            return PLUGIN_CONTINUE;
        }
        else client_print_color(id, "%s ^3No arenas found.",CHAT_TAG)
    }
    else if(equali(szName,"Load"))
    {
        remove_the_fake_arena() 
        load_arena_coords(id)
        //client_print_color(id, "%s ^3Arena coords loaded.",CHAT_TAG)
        set_task(0.1,"delay_build",id)
    }
    else if(equali(szName,"Save"))
    {
        if(fakes_count())
        {
            save_arena_coords(id)
            remove_the_fake_arena() 
            load_arena_coords(id)
        }
        else
        {
            client_print_color(id, "%s ^3No arenas found.",CHAT_TAG)
        }
    }
    if(!arenas_found && fakes_count())
    {
        next_selection()
    }
    menu_destroy( menu );
    editor_menu(id)
    set_pev(id, pev_groupinfo, GROUP_ENTITY | GROUP_PLAYER);
    return PLUGIN_CONTINUE;
}
 
stock next_selection()
{
    if(selected == -1)
    {
        selected = 1
    }
    new size = MAX_ARENAS*3
    for(new slct=0;slct < size;slct++)
    {
        selected++
        if(selected > MAX_ARENAS)
            selected = 1
        if(fake_arena_exists(selected))
        {
            select_the_fake_arena(EXTRA_CODE+selected)
            return;
        }
    }
}
 
public fake_arena_exists(code)
{
    new arenas_ent = -1
    new code_ent
    while((arenas_ent=engfunc(EngFunc_FindEntityByString,arenas_ent,"classname",ARENA_ENT_NAME))) 
    {
        if(entity_get_int(arenas_ent,EV_INT_iuser2) == CENTER_CODE && entity_get_int(arenas_ent,EV_INT_iuser1) == FAKE_CODE)
        {
            code_ent = entity_get_int(arenas_ent,EV_INT_iuser3)-EXTRA_CODE
            if(code_ent == code)
            {
                return PLUGIN_HANDLED
            }
        }
    }
    return PLUGIN_CONTINUE
}
 
public fakes_count()
{
    new arenas_ent = -1
    new found = 0
    while((arenas_ent=engfunc(EngFunc_FindEntityByString,arenas_ent,"classname",ARENA_ENT_NAME))) 
    {
        if(entity_get_int(arenas_ent,EV_INT_iuser2) == CENTER_CODE && entity_get_int(arenas_ent,EV_INT_iuser1) == FAKE_CODE)
        {
            found++
        }
    }
    return found
}
 
public arenas_count()
{
    new found = 0
    for(new id;id < MAXPLAYERS;id++)
    {
        if(is_user_connected(id))
        {
            if(is_in_duel[id] == 2)
                found++
        }
    }
    return found/2
}
 
public delay_build(id)
{
    for(new i=1;i < total_arenas+1;i++)
    {
        start_fake_build(id,i)
    }
    if(fakes_count())
    {
        next_selection()
    }
}
public move_menu(id,code)
{
    new menu
    menu = menu_create( "\rMove arena:", "move_handler" );
    
    new nameu[32];
    new code_t[32];
    num_to_str(code,code_t,charsmax(code_t))
    formatex(nameu,charsmax(nameu), "Move up");
    menu_additem(menu, nameu, code_t, 0);
    
    formatex(nameu,charsmax(nameu), "Move down");
    menu_additem(menu, nameu, code_t, 0);
    
    formatex(nameu,charsmax(nameu), "Move front");
    menu_additem(menu, nameu, code_t, 0);
    
    formatex(nameu,charsmax(nameu), "Move back");
    menu_additem(menu, nameu, code_t, 0);
    
    formatex(nameu,charsmax(nameu), "Move right");
    menu_additem(menu, nameu, code_t, 0);
    
    formatex(nameu,charsmax(nameu), "Move left");
    menu_additem(menu, nameu, code_t, 0);
    
    formatex(nameu,charsmax(nameu), "Remove the arena");
    menu_additem(menu, nameu, code_t, 0);
    
    formatex(nameu,charsmax(nameu), "Move size: %.2f",move_size[id]);
    menu_additem(menu, nameu, code_t, 0);
    menu_display(id, menu, 0 );
    return PLUGIN_HANDLED
}
 
public move_handler( id, menu, item )
{
    if ( item == MENU_EXIT )
    {
        menu_destroy( menu );
        set_task(0.1,"editor_menu",id)
        return PLUGIN_HANDLED;
    }
    
    new szData[32], szName[64];
    new _access, item_callback;
    menu_item_getinfo( menu, item, _access, szData,charsmax( szData ), szName,charsmax( szName ), item_callback );
    new code = str_to_num(szData)
    if(equali(szName,"remove the arena"))
    {
        delete_the_fake_arena(code)
        menu_destroy( menu );
        editor_menu(id)
        unselect_the_fake_arena(0)
        return PLUGIN_CONTINUE;
    }
    else if(containi(szName,"move size:") != -1)
    {
        move_size[id]+= 10.0
        if(move_size[id] > 100.0)
        {
            move_size[id] = 10.0
        }
    }
    else if(equali(szName,"move up"))
    {
        move_the_fake_arena(id,code,MOVE_UP)
    }
    else if(equali(szName,"move down"))
    {
        move_the_fake_arena(id,code,MOVE_DOWN)
    }
    else if(equali(szName,"move right"))
    {
        move_the_fake_arena(id,code,MOVE_RIGHT)
    }
    else if(equali(szName,"move left"))
    {
        move_the_fake_arena(id,code,MOVE_LEFT)
    }
    else if(equali(szName,"move front"))
    {
        move_the_fake_arena(id,code,MOVE_FRONT)
    }
    else if(equali(szName,"move back"))
    {
        move_the_fake_arena(id,code,MOVE_BACK)
    }
    menu_destroy( menu );
    move_menu(id,code)
    
    return PLUGIN_CONTINUE;
}
 
public save_arena_coords(id)
{
    new found;
    new cfgdir[32], mapname[32], urlfile[64]
    get_configsdir(cfgdir, charsmax(cfgdir))
    get_mapname(mapname, charsmax(mapname))
    formatex(urlfile, charsmax(urlfile), ARENA_FILE, cfgdir, mapname)
 
    if (file_exists(urlfile))
        delete_file(urlfile)
    
    new lineset[128]
    new Float:origin[3]
    new arenas_ent=-1;
    while((arenas_ent=engfunc(EngFunc_FindEntityByString,arenas_ent,"classname",ARENA_ENT_NAME))) 
    {
        if(entity_get_int(arenas_ent,EV_INT_iuser2) == CENTER_CODE && entity_get_int(arenas_ent,EV_INT_iuser1) == FAKE_CODE)
        {
            found++
            pev(arenas_ent,pev_origin,origin);
            format(lineset, charsmax(lineset), "%.f %.f %.f", origin[0], origin[1], origin[2])
            write_file(urlfile, lineset,found)
            
        }
    }
    if(!found)
        client_print_color(id, "%s Couldn't save:^3No arenas found.",CHAT_TAG)
    else client_print_color(id, "%s %d ^3Arena coords saved.",CHAT_TAG,found)
}
 
public print_coords(id)
{
    new Float:coord[3]
    pev(id,pev_origin,coord);
    client_print_color(id, "origin: ^3%.f %.f %.f",coord[0],coord[1],coord[2])
    return PLUGIN_HANDLED
}
 
public start_fake_build(id,zecode)
{
    if(!is_user_connected(id))
        return PLUGIN_HANDLED
    new ext_code
    if(zecode == -1)
    {
        ext_code = next_fake_arena()
        if(ext_code == -1)
            return PLUGIN_HANDLED
    }
    else 
        ext_code = zecode
    ext_code+=EXTRA_CODE
    static Float:origin[3];
    if(zecode == -1)
        get_user_hitpoint(id,origin)
    else
    {
        origin[0]=arena_coord[zecode][0]
        origin[1]=arena_coord[zecode][1]
        origin[2]=arena_coord[zecode][2]
    }
    
    /*origin[0] = 1002.911376
    origin[1] = -1561.421997
    origin[2] = 0.0*/
    new Float:fake_origin[3]
    static size
    size = sizeof(ARENA_COORDS)
    new ent_code = FAKE_CODE
    fakes++
    for(new coords;coords < size; coords++)
    {
        fake_origin[0] = origin[0]
        fake_origin[1] = origin[1]
        if(bugged_map())
            fake_origin[2]= MAP_FIX_Z_COORD[map_id]
        else fake_origin[2] = origin[2]
        //fake_origin[2]=-712.876892
        
        fake_origin[0]+=ARENA_COORDS[coords][0]*1.7
        fake_origin[1]+=ARENA_COORDS[coords][1]*1.53
        
        new ent=engfunc(EngFunc_CreateNamedEntity,engfunc(EngFunc_AllocString,"func_wall"));
        
        set_pev(ent,pev_classname,ARENA_ENT_NAME);
        engfunc(EngFunc_SetModel,ent,ARENA_MODELS[0]);
        entity_set_int(ent, EV_INT_solid, SOLID_BBOX);
        engfunc(EngFunc_SetSize,ent,ARENA_MINS,ARENA_MAXS);
        entity_set_int(ent, EV_INT_movetype, MOVETYPE_NONE);
        entity_set_int(ent,EV_INT_iuser1,ent_code)
        entity_set_int(ent,EV_INT_iuser3,ext_code)
        set_pev(ent, pev_groupinfo, GROUP_ENTITY);
        engfunc(EngFunc_SetOrigin,ent,fake_origin);
        stuck_check(fake_origin,120.0)
        static Float:rvec[3];
        pev(ent,pev_v_angle,rvec);
        
        rvec[0]=0.0;
        set_pev(ent,pev_angles,rvec);
        
        if(ARENA_COORDS[coords][0] == 0.0 && ARENA_COORDS[coords][1] == 100.0)
        {
            fake_origin[0] += max_size[0]
            fake_origin[1] += max_size[1]
        }
        if(ARENA_COORDS[coords][0] == 0.0 && ARENA_COORDS[coords][1] == -100.0)
        {
            fake_origin[0] += max_size[2]
            fake_origin[1] += min_size[0]
        }
        if(ARENA_COORDS[coords][0] == 0.0 && ARENA_COORDS[coords][1] == 0.0)
        {
            entity_set_int(ent,EV_INT_iuser2,CENTER_CODE)
        }
        else if(ARENA_COORDS[coords][0] == 200.0 && ARENA_COORDS[coords][1] == 0.0)
        {
            fake_origin[0] += min_size[1]
        }
        else if(ARENA_COORDS[coords][0] == -100.0 && ARENA_COORDS[coords][1] == 0.0)
        {
            fake_origin[0] += min_size[2]
        }
 
        
        
        set_rendering(ent,kRenderFxGlowShell,0,50,0,kRenderNormal,10)
    }
    select_the_fake_arena(ext_code)
    return PLUGIN_HANDLED;
}
 
public move_the_fake_arena(id,code,moveto)
{
    new num;
    num = code-EXTRA_CODE
    new arenas_ent=-1;
    new Float:origin[3];
    while((arenas_ent=engfunc(EngFunc_FindEntityByString,arenas_ent,"classname",ARENA_ENT_NAME))) 
    {
        if(entity_get_int(arenas_ent,EV_INT_iuser1) == FAKE_CODE)
        {
            if(entity_get_int(arenas_ent,EV_INT_iuser3) == code || num == -1)
            {
                pev(arenas_ent,pev_origin,origin);
                switch(moveto)
                {
                    case MOVE_UP:
                    {
                        origin[2]+=move_size[id]
                    }
                    case MOVE_DOWN:
                    {
                        origin[2]-=move_size[id]
                    }
                    case MOVE_RIGHT:
                    {
                        origin[1]+=move_size[id]
                    }
                    case MOVE_LEFT:
                    {
                        origin[1]-=move_size[id]
                    }
                    case MOVE_FRONT:
                    {
                        origin[0]+=move_size[id]
                    }
                    case MOVE_BACK:
                    {
                        origin[0]-=move_size[id]
                    }
                }
                engfunc(EngFunc_SetOrigin,arenas_ent,origin);
                stuck_check(origin,360.0)
            }
        }
    }
    
}
 
public select_the_fake_arena(code)
{
    new num;
    num = code-EXTRA_CODE
    new arenas_ent=-1;
    while((arenas_ent=engfunc(EngFunc_FindEntityByString,arenas_ent,"classname",ARENA_ENT_NAME))) 
    {
        if(entity_get_int(arenas_ent,EV_INT_iuser1) == FAKE_CODE)
        {
            if(num == -1)
                set_rendering(arenas_ent,kRenderFxGlowShell,250,0,0,kRenderNormal,10)
            else if(entity_get_int(arenas_ent,EV_INT_iuser3) == code)
                set_rendering(arenas_ent,kRenderFxGlowShell,250,0,0,kRenderNormal,10)
        }
    }
    unselect_the_fake_arena(code)
    
}
 
public unselect_the_fake_arena(code)
{
    new num;
    num = code-EXTRA_CODE
    if(num == -1)
        return;
    new arenas_ent=-1;
    while((arenas_ent=engfunc(EngFunc_FindEntityByString,arenas_ent,"classname",ARENA_ENT_NAME))) 
    {
        if(entity_get_int(arenas_ent,EV_INT_iuser1) == FAKE_CODE && entity_get_int(arenas_ent,EV_INT_iuser3) != code)
            set_rendering(arenas_ent,kRenderFxGlowShell,50,50,50,kRenderTransAdd,120)
    }
    
}
 
public delete_the_fake_arena(code)
{
    new arenas_ent=-1;
    new found = 0
    while((arenas_ent=engfunc(EngFunc_FindEntityByString,arenas_ent,"classname",ARENA_ENT_NAME))) 
    {
        if(entity_get_int(arenas_ent,EV_INT_iuser1) == FAKE_CODE && entity_get_int(arenas_ent,EV_INT_iuser3) == code)
        {
            engfunc(EngFunc_RemoveEntity,arenas_ent)
            found++
        }
    }
    if(found)
    {
        fakes--
    }
    
}
 
public load_arena_coords(id)
{
    // Check for spawns points of the current map
    new cfgdir[32], mapname[32], filepath[100], linedata[64]
    get_configsdir(cfgdir, charsmax(cfgdir))
    get_mapname(mapname, charsmax(mapname))
    formatex(filepath, charsmax(filepath), ARENA_FILE, cfgdir, mapname)
    new arena = 0
    total_arenas = 0
    // Load spawns points
    if (file_exists(filepath))
    {
        new file = fopen(filepath,"rt"), row[4][6]
        
        while (file && !feof(file))
        {
            fgets(file, linedata, charsmax(linedata))
            
            // invalid spawn
            if(!linedata[0] || str_count(linedata,' ') < 2) continue;
            
            arena++
            if (arena > MAX_ARENAS)
            {
                break
            }
            
            // get spawn point data
            parse(linedata,row[0],5,row[1],5,row[2],5)
            
            // origin
            arena_coord[arena][0] = floatstr(row[0])
            arena_coord[arena][1] = floatstr(row[1])
            if(bugged_map())
                arena_coord[arena][2] = MAP_FIX_Z_COORD[map_id]
            else arena_coord[arena][2] = floatstr(row[2])
 
            total_arenas = arena
        }
        if (file) fclose(file)
    }
    if(id != -1)
    {
        if(!total_arenas)
        {
            client_print_color(id, "%sCouldn't load: ^3No arenas found.",CHAT_TAG)
        }
        else
        {
            client_print_color(id, "%s%d ^3arena%s loaded.",CHAT_TAG,total_arenas, (total_arenas > 1 ? "s" : ""))
        }
    }
}
 
stock bugged_map()
{
    if(!MAP_FIX_ENABLED)
        return PLUGIN_CONTINUE
    if(IS_BUGGED_MAP)
        return PLUGIN_HANDLED
    return PLUGIN_CONTINUE
}
 
stock str_count(const str[], searchchar)
{
    new count, i, len = strlen(str)
    
    for (i = 0; i <= len; i++)
    {
        if(str[i] == searchchar)
            count++
    }
    
    return count;
}
 
public Player_spawn_post(id)
{
    Set_Entity_Invisible(id, 0)
    if(is_user_alive(id))
    {
        if(is_in_duel[id] != 2)
        {
            set_task(1.0,"get_spawn_origin",id)
            return;
        }
        if(is_in_duel[id] == 2)
            spawn_back(id)
    }
}
 
public spawn_back(id)
{
    entity_set_origin(id,his_player_spawn[id])
    entity_set_vector(id, EV_VEC_angles, his_player_angle[id])
    
    set_user_armor(id,0)
    set_user_godmode(id, 0)
    if(is_user_connected(his_challenger[id]))
    {
        check_teams(id,his_challenger[id])
        entity_set_origin(his_challenger[id],his_player_spawn[his_challenger[id]])
        entity_set_vector(id, EV_VEC_angles, his_player_angle[id])
        set_user_armor(his_challenger[id],0)
        entity_set_int(id, EV_INT_fixangle, 1)
        entity_set_vector(his_challenger[id], EV_VEC_angles, his_player_angle[his_challenger[id]])
        entity_set_int(his_challenger[id], EV_INT_fixangle, 1)
 
        if(his_arena[id] == 2)
             {
                      his_arena[his_challenger[id]] = 2;
                 set_user_health(id,100)
            set_user_health(his_challenger[id],100)
             }
        else
        {
            set_user_health(his_challenger[id],map_default_hp)
            set_user_health(id,map_default_hp)
        }
        
        strip_user_weapons(id)
        strip_user_weapons(his_challenger[id])
        
        CopyWeaponSettings(id)
        CopyWeaponSettings(his_challenger[id])
        
        give_item(id, WeaponModel[Weapons_Settings[id]]);
        give_item(his_challenger[id], WeaponModel[Weapons_Settings[his_challenger[id]]]);
        
                  if(his_types[id] == 1)
                  {
                      his_types[his_challenger[id]] = 1 
                  }
                  else if(his_types[id] == 2)
                  {
                      his_types[his_challenger[id]] = 2 
                  }
                  if(his_types[id] == 3)
                  {
                      his_types[his_challenger[id]] = 3 
                  }
                  else if(his_types[id] == 4)
                  {
                      his_types[his_challenger[id]] = 4 
                  }
    }
}
 
public update_cvars()
{
    MAP_FIX_ENABLED = get_pcvar_num(cvar_z_fix)
    SOUNDS_ENABLED = get_pcvar_num(cvar_sounds)
    MAX_ROUNDS = get_pcvar_num(cvar_rounds)
    MAX_KILLS = get_pcvar_num(cvar_kills)
    MAX_COUNTDOWN = get_pcvar_num(cvar_cooldown)
    MAX_TIME = get_pcvar_num(cvar_time)
}
 
stock remove_allarenas() 
{
    new arenas_ent=-1;
    while((arenas_ent=engfunc(EngFunc_FindEntityByString,arenas_ent,"classname",ARENA_ENT_NAME))) 
    {
        engfunc(EngFunc_RemoveEntity,arenas_ent)
    }
    fakes = 0
}
 
public get_all_arena_coords(id) 
{
    new Float:origin[3]
    new arenas_ent=-1;
    while((arenas_ent=engfunc(EngFunc_FindEntityByString,arenas_ent,"classname",ARENA_ENT_NAME))) 
    {
        if(entity_get_int(arenas_ent,EV_INT_iuser2) == CENTER_CODE)
        {
            pev(arenas_ent,pev_origin,origin);
            client_print(id,print_console,"%.f %.f %.f",origin[0],origin[1],origin[2])
        }
    }
    client_print_color(id,  "%s ^4Coords printed in console.",CHAT_TAG)
}
 
public remove_the_fake_arena() 
{
    new arenas_ent=-1;
    while((arenas_ent=engfunc(EngFunc_FindEntityByString,arenas_ent,"classname",ARENA_ENT_NAME))) 
    {
        if(entity_get_int(arenas_ent,EV_INT_iuser1) == FAKE_CODE)
            engfunc(EngFunc_RemoveEntity,arenas_ent)
    }
    fakes = 0
}
 
public next_fake_arena() 
{
    if(fakes_count() >= MAX_ARENAS)
        return -1
    for(new i=1;i < MAX_ARENAS+1;i++)
    {
        if(!fake_arena_exists(i))
        {
            return i
        }
    }
    return -1
    /*new num = fakes
    num++
    return num*/
}
 
public remove_the_arena(code) 
{
    new arenas_ent=-1;
    while((arenas_ent=engfunc(EngFunc_FindEntityByString,arenas_ent,"classname",ARENA_ENT_NAME))) 
    {
        if(entity_get_int(arenas_ent,EV_INT_iuser1) == code)
            engfunc(EngFunc_RemoveEntity,arenas_ent)
    }
}
 
public start_build(id)
{
    if(!is_user_connected(id))
        return PLUGIN_HANDLED
    if(is_in_duel[id] != 2)
        return PLUGIN_HANDLED
    if(!his_challenger[id])
        return PLUGIN_HANDLED
    if(!total_arenas)
    {
        return PLUGIN_HANDLED
    }
    static Float:origin[3];
        
 
    origin[0] = arena_coord[arena_number[id]][0]
    origin[1] = arena_coord[arena_number[id]][1]
    origin[2] = arena_coord[arena_number[id]][2]
 
    new Float:fake_origin[3]
    static size
    size = sizeof(ARENA_COORDS)
    new ent_code = arena_number[id]+ARENA_CODE
    for(new coords;coords < size; coords++)
    {
        fake_origin[0] = origin[0]
        fake_origin[1] = origin[1]
        fake_origin[2] = origin[2]
 
        fake_origin[0]+=ARENA_COORDS[coords][0]*1.7
        fake_origin[1]+=ARENA_COORDS[coords][1]*1.53
        
        if(his_arena[id] == 0)
        {
            new ent=engfunc(EngFunc_CreateNamedEntity,engfunc(EngFunc_AllocString,"func_wall"));
             
            set_pev(ent,pev_classname,ARENA_ENT_NAME);  
            engfunc(EngFunc_SetModel,ent,ARENA_MODELS[0]);
            entity_set_int(ent, EV_INT_solid, SOLID_BBOX);
            engfunc(EngFunc_SetSize,ent,ARENA_MINS,ARENA_MAXS);
            entity_set_int(ent, EV_INT_movetype, MOVETYPE_NONE);
            entity_set_int(ent,EV_INT_iuser1,ent_code);
            engfunc(EngFunc_SetOrigin,ent,fake_origin);
            set_pev(ent, pev_groupinfo, GROUP_ENTITY);
        }
        if(his_arena[id] == 1)
        {
            new ent_bridge=engfunc(EngFunc_CreateNamedEntity,engfunc(EngFunc_AllocString,"func_wall"));
            
            set_pev(ent_bridge,pev_classname,ARENA_ENT_NAME);   
            engfunc(EngFunc_SetModel,ent_bridge,BRIDGE_MODELS[0]);
            entity_set_int(ent_bridge, EV_INT_solid, SOLID_BBOX);
            engfunc(EngFunc_SetSize,ent_bridge,BRIDGE_MINS,BRITGE_MAXS);
            entity_set_int(ent_bridge, EV_INT_movetype, MOVETYPE_NONE);
            entity_set_int(ent_bridge,EV_INT_iuser1,ent_code)
            engfunc(EngFunc_SetOrigin,ent_bridge,fake_origin);
            set_pev(ent_bridge, pev_groupinfo, GROUP_ENTITY);
        }
        if(his_arena[id] == 2)
        {
            new ent=engfunc(EngFunc_CreateNamedEntity,engfunc(EngFunc_AllocString,"func_wall"));
            
            set_pev(ent,pev_classname,ARENA_ENT_NAME);  
            engfunc(EngFunc_SetModel,ent,ARENA_MODELS[0]);
       entity_set_int(ent, EV_INT_solid, SOLID_BBOX);
            engfunc(EngFunc_SetSize,ent,ARENA_MINS,ARENA_MAXS);
            entity_set_int(ent, EV_INT_movetype, MOVETYPE_NONE);
            entity_set_int(ent,EV_INT_iuser1,ent_code);
            engfunc(EngFunc_SetOrigin,ent,fake_origin);
       set_pev(ent, pev_groupinfo, GROUP_ENTITY);
            
            static Float:box_origin[3];
            
            box_origin[0] = arena_coord[arena_number[id]][0]
            box_origin[1] = arena_coord[arena_number[id]][1]
            box_origin[2] = arena_coord[arena_number[id]][2]
            
            new Float:box_fake_origin[3]
            static boxsize
            boxsize = sizeof(BOX_COORDS)
            new box_ent_code = arena_number[id]+ARENA_CODE
            for(new coords;coords < boxsize; coords++)
            {
                box_fake_origin[0] = box_origin[0]
                box_fake_origin[1] = box_origin[1]
                box_fake_origin[2] = box_origin[2]+50
                
                box_fake_origin[0]+=BOX_COORDS[coords][0]*1.7
                box_fake_origin[1]+=BOX_COORDS[coords][1]*1.53
                new entbox = engfunc(EngFunc_CreateNamedEntity,engfunc(EngFunc_AllocString,"func_wall"));
                set_pev(entbox,pev_classname,ARENA_ENT_NAME);
                engfunc(EngFunc_SetModel,entbox,BOX_MODELS[0]);
                entity_set_int(entbox, EV_INT_solid, SOLID_BBOX);
                engfunc(EngFunc_SetSize,entbox,BOX_MINS,BOX_MAXS);
                entity_set_int(entbox, EV_INT_movetype, MOVETYPE_NONE);
                entity_set_int(entbox,EV_INT_iuser1,box_ent_code);
                engfunc(EngFunc_SetOrigin,entbox,box_fake_origin);
                set_pev(entbox, pev_groupinfo, GROUP_ENTITY);
            }
        }
    }
    static Float:rvec[3];
 
    rvec[0]=0.0;
 
    cs_set_user_team(id,CS_TEAM_T)
    cs_set_user_team(his_challenger[id],CS_TEAM_CT)
        
    set_spawn_positions(id,fake_origin)
    set_spawn_positions(his_challenger[id],fake_origin)
 
    spawn_back(id)
 
    return PLUGIN_HANDLED;
}
 
public set_spawn_positions(id,Float:origin[3])
{
    if(get_user_team(id) == 1)
    {
        his_player_spawn[id][0] = origin[0]-340
        his_player_spawn[id][1] = origin[1]
        his_player_spawn[id][2] = origin[2]+50
        his_player_angle[id][1] = 0.0
        his_player_angle[id][0] = 0.0
    }
    if(get_user_team(id) == 2)
    {
        his_player_spawn[id][0] = origin[0]+340
        his_player_spawn[id][1] = origin[1]
        his_player_spawn[id][2] = origin[2]+50
        his_player_angle[id][1] = 180.0
        his_player_angle[id][0] = 0.0 
    }
    entity_set_origin(id,his_player_spawn[id])
}
 
 
 
public stuck_check(Float:origin[3],Float:radius)
{
    new player=-1;
    while((player = find_ent_in_sphere(player,origin,radius)) != 0)
    {
        if(is_user_alive(player))
        {
            if(is_player_stuck(player) && is_in_duel[player] != 2)
            {
                back_to_the_spawn(player)
            }
        }
    }
}
 
stock is_player_stuck(id)
{
    static Float:originF[3]
    pev(id, pev_origin, originF)
    
    engfunc(EngFunc_TraceHull, originF, originF, 0, (pev(id, pev_flags) & FL_DUCKING) ? HULL_HEAD : HULL_HUMAN, id, 0)
    
    if (get_tr2(0, TR_StartSolid) || get_tr2(0, TR_AllSolid) || !get_tr2(0, TR_InOpen))
        return true;
    
    return false;
}
 
public create_wall(type,alpha,solidity,code,code1,code2,Float:origin[3])
{
    new Float:wall_maxsize[3];
    new Float:wall_minsize[3];
    new Float:rvec[3];
    new ent=engfunc(EngFunc_CreateNamedEntity,engfunc(EngFunc_AllocString,"func_wall"));
    pev(ent,pev_v_angle,rvec);
    switch(type)
    {
        case BLUE_SIDE:
        {
            wall_maxsize[0] = 2.0
            wall_minsize[0] = 0.0
            wall_maxsize[1] = 230.0
            wall_minsize[1] = -230.0
            wall_maxsize[2] = 150.0
            wall_minsize[2] = -1.0
            rvec[1]=180.0
        }
        case RED_SIDE:
        {
            wall_maxsize[0] = -150.0
            wall_minsize[0] = -152.0
            wall_maxsize[1] = 230.0
            wall_minsize[1] = -230.0
            wall_maxsize[2] = 150.0
            wall_minsize[2] = -1.0
            rvec[1]=180.0
        }
        case LEFT_SIDE:
        {
            wall_maxsize[0] = 360.0
            wall_minsize[0] = -300.0
            wall_maxsize[1] = 65.0
            wall_minsize[1] = 63.0
            wall_maxsize[2] = 150.0
            wall_minsize[2] = -1.0
            rvec[1]=90.0
        }
        case RIGHT_SIDE:
        {
            wall_maxsize[0] = 360.0
            wall_minsize[0] = -300.0
            wall_maxsize[1] = -63.0
            wall_minsize[1] = -65.0
            wall_maxsize[2] = 150.0
            rvec[1]=90.0
        }
        case TOP_SIDE:
        {
            wall_maxsize[0] = 360.0
            wall_minsize[0] = -300.0
            wall_maxsize[1] = 230.0
            wall_minsize[1] = -230.0
            wall_maxsize[2] = 150.0
            wall_minsize[2] = 148.0
            rvec[0]=90.0          
        }
    }
    set_pev(ent,pev_angles,rvec);
    
    set_pev(ent,pev_classname,ARENA_ENT_NAME);
    engfunc(EngFunc_SetModel,ent,ARENA_MODELS[0]);
    entity_set_int(ent, EV_INT_solid, solidity);
    engfunc(EngFunc_SetSize,ent,wall_minsize,wall_maxsize);
    entity_set_int(ent, EV_INT_movetype, MOVETYPE_NONE);
    entity_set_int(ent,EV_INT_iuser1,code)
    entity_set_int(ent,EV_INT_iuser2,code1)
    entity_set_int(ent,EV_INT_iuser3,code2)
    engfunc(EngFunc_SetOrigin,ent,origin);
    set_rendering(ent,kRenderFxGlowShell,0,0,0,kRenderTransAlpha,alpha)
}
 
public get_spawn_origin(id)
{
    pev(id,pev_origin,his_original_spawn[id]);
}
 
stock get_user_hitpoint(id,Float:hOrigin[3])  {
    if(!is_user_alive(id))
        return 0;
 
    new Float:fOrigin[3],Float:fvAngle[3],Float:fvOffset[3],Float:fvOrigin[3],Float:feOrigin[3];
    new Float:fTemp[3];
 
    pev(id,pev_origin,fOrigin);
    pev(id,pev_v_angle,fvAngle);
    pev(id,pev_view_ofs,fvOffset);
 
    xs_vec_add(fOrigin,fvOffset,fvOrigin);
 
    engfunc(EngFunc_AngleVectors,fvAngle,feOrigin,fTemp,fTemp);
 
    xs_vec_mul_scalar(feOrigin,9999.9,feOrigin);
    xs_vec_add(fvOrigin,feOrigin,feOrigin);
 
    engfunc(EngFunc_TraceLine,fvOrigin,feOrigin,0,id);
    global_get(glb_trace_endpos,hOrigin);
 
    return 1;
} 
 
public plugin_precache() 
{
    new size;
    new bridge_size;
    new box_size;
    size = sizeof(ARENA_MODELS)
    bridge_size = sizeof(BRIDGE_MODELS)
    box_size = sizeof(BOX_MODELS)
    
    for(new i; i< size; i++) 
    {
        engfunc(EngFunc_PrecacheModel,ARENA_MODELS[i]);
    }
    for(new i; i< bridge_size; i++) 
    {
        engfunc(EngFunc_PrecacheModel,BRIDGE_MODELS[i]);
    }
    for(new i; i< box_size; i++) 
    {
        engfunc(EngFunc_PrecacheModel,BOX_MODELS[i]);
    }
}
 
 
public round_start_event()
{
    update_cvars()
    // using a variable to store player's names instead of regenerating it all the time...
    for(new id;id < MAXPLAYERS;id++)
    {
        if(is_user_connected(id))
        {
            get_user_name(id,his_name[id],charsmax(his_name))
        }
    }
}
 
public Advertise(task)
{
    client_print_color(0, "%s^3%s ^1by ^4%s ^1for ^4%s^1.",CHAT_TAG,P_NAME,P_AUTH,P_REQ)
    set_task(300.0,"Advertise",TASK_AD)
}
 
public Cmd_start(id,hndle)
{
    if(!is_user_alive(id))
        return FMRES_IGNORED
    if(!is_frozen[id])
        return FMRES_IGNORED
    new Buttons = get_uc(hndle,UC_Buttons)
    if(Buttons & IN_ATTACK)
    {
        Buttons &= ~IN_ATTACK
        set_uc( hndle , UC_Buttons , Buttons )
        return FMRES_SUPERCEDE
    }
    if(Buttons & IN_ATTACK2)
    {
        Buttons &= ~IN_ATTACK2
        set_uc( hndle , UC_Buttons , Buttons )
        return FMRES_SUPERCEDE
    }
    return FMRES_IGNORED
}
 
public Player_Take_Damage(victim, inflictor, attacker, Float:damage, damage_bits)
{     
    if(is_user_connected(attacker)) // we make sure the attacker is a player
    {
        if(is_in_duel[victim] == 2 || is_in_duel[attacker] == 2)
        {
            if(his_challenger[victim] != attacker || his_challenger[attacker] != victim)
            {
                // we protect the contenders from getting killed by other people or them killing others?
                return HAM_SUPERCEDE
            }
        }
    }
    return HAM_IGNORED
}
 
public client_putinserver(id)
{
    get_user_name(id,his_name[id],charsmax(his_name))
    reset_values(id)
    move_size[id] = 10.0
    his_offline[id] = 0
    his_previous_team[id] = 0
    arena_selected = 1;
}
 
public client_disconnect(id)
{
    end_his_duel(id)
}
 
public end_his_duel(id)
{
    if(his_challenger[id])
    {
        client_print_color(0, "^3[^4Arena: %s^3] ^4%s^1's challenger ^4%s^1 has ^3left the game^1.",arena_names[arena_number[id]],his_name[his_challenger[id]],his_name[id])
        
        if(arena_number[id] == arena_number[his_challenger[id]])
            remove_the_arena(arena_number[id] +ARENA_CODE)
        back_to_the_spawn(id)
        back_to_the_spawn(his_challenger[id])
        reset_values(his_challenger[id])
    }
    reset_values(id)
}
 
public times_up_duel(id)
{
    client_print_color(0, "^3[^4Arena: %s^3] ^4%s^1 ^1and ^4%s^1 has taken long to ^3finish the battle^1.",arena_names[arena_number[id]],his_name[his_challenger[id]],his_name[id])
        
    if(his_challenger[id])
    {
        if(arena_number[id] == arena_number[his_challenger[id]])
            remove_the_arena(arena_number[id] +ARENA_CODE)
        user_kill(id,1)
        user_kill(his_challenger[id],1)
        back_to_the_spawn(id)
        back_to_the_spawn(his_challenger[id])
        reset_values(his_challenger[id])
    }
    reset_values(id)
}
 
public battle_timer(id)
{
    if(is_user_connected(id))
    {
        if(is_in_duel[id] == 2)
        {
            his_timer[id]++
            if(his_timer[id] > MAX_TIME)
            {
                times_up_duel(id)
            }
            set_task(1.0,"battle_timer",id)
        }
    }
}
 
public say_hook(id)
{
    static Chat_C[32]
    read_args(Chat_C,charsmax(Chat_C))
    remove_quotes(Chat_C)
    if(equali(Chat_C,DUEL_COMMAND))
    {
        //request a duel
        Principal_Menu(id)
    }
    if(equali(Chat_C,TOGGLE_COMMAND))
    {
        //request a duel
        toggle_offline(id)
    }
    if(equali(Chat_C,GIVEUP_COMMAND))
    {
        //leave a duel
        if(is_in_duel[id] == 2)
        {
            give_up_player(id)
        }
        else
        {
            client_print_color(id, "%sYou're not part of any battle.",CHAT_TAG)
        }
    }
    return PLUGIN_CONTINUE
}
 
public toggle_offline(id)
{
    switch(his_offline[id])
    {
        case 0:
        {
            his_offline[id] = 1
            //client_print_color(0, "%s^4%s^1 disconnected from the duel list.",CHAT_TAG,his_name[id])
        }
        default:
        {
            his_offline[id] = 0
            //client_print_color(0, "%s^4%s^1 connected to the duel list.",CHAT_TAG,his_name[id])
        }
    }
}
 
public give_up_player(id)
{
    if(is_user_connected(his_challenger[id]))
    {
        strip_user_weapons(id)
        strip_user_weapons(his_challenger[id])
        give_item(id,"weapon_knife")
        give_item(his_challenger[id],"weapon_knife")
        
        client_print_color(0, "%s^4%s^3 got scared to face ^4%s^3! :)",CHAT_TAG,his_name[id],his_name[his_challenger[id]])
        if(arena_number[id] == arena_number[his_challenger[id]])
            remove_the_arena(arena_number[id] +ARENA_CODE)
        back_to_the_spawn(id)
        back_to_the_spawn(his_challenger[id])
        reset_values(his_challenger[id])
    }
    reset_values(id)
}
 
public reward_winner(id)
{
    if(is_user_connected(id))
    {
        strip_user_weapons(id)
        give_item(id,"weapon_knife")
        // here you can reward the winner with something
        client_print_color(id, "%s^4Congratulations!!!^1, You have ^3won this battle^1!",CHAT_TAG)
        if(SOUNDS_ENABLED)
            client_cmd(id,"spk ^"%s^"",DUEL_SOUNDS[0])
        if(cs_get_user_money(id)+15000 <= 16000)
        {
            cs_set_user_money(id,cs_get_user_money(id)+15000,1)
            //client_print_color(id, "%s^4You've earned ^3$15000^4!",CHAT_TAG)
        } else cs_set_user_money(id,16000,1)
    }
}
 
public reward_loser(id)
{
    if(is_user_connected(id))
    {
        // here you can reward the winner with something
        strip_user_weapons(id)
        give_item(id,"weapon_knife")
        user_kill(id,1)
        client_print_color(id, "%sYou've ^3lost this battle^1!",CHAT_TAG)
        if(SOUNDS_ENABLED)
            client_cmd(id,"spk ^"%s^"",DUEL_SOUNDS[1])
        if(cs_get_user_money(id)-15000 >= 0)
        {
            cs_set_user_money(id,cs_get_user_money(id)-15000,1)
            //client_print_color(id, "%s^4You've lost ^3$15000^4!",CHAT_TAG)
        } else cs_set_user_money(id,0,1)
    }
}
 
public duel_players_list(id)
{
    if(!is_user_alive(id))
    {
        client_print_color(id, "%sYou can't challenge anyone when you're ^3dead1.",CHAT_TAG)
        return PLUGIN_HANDLED
    }
    if(his_offline[id])
    {
        client_print_color(id, "%sYou can't challenge people when you're ^3offline^1.",CHAT_TAG)
        return PLUGIN_HANDLED
    }
    if(is_user_connected(his_challenger[id]))
    {
        client_print_color(id, "%s^4%s ^1is still ^4fighting against you^1.",CHAT_TAG,his_name[his_challenger[id]])
        return PLUGIN_HANDLED
    }
    if(is_user_connected(his_asker[id]))
    {
        client_print_color(id, "%sYou can only ^3challenge one person^1 at the time, you've challenged ^4%s^1.",CHAT_TAG,his_name[his_asker[id]])
        return PLUGIN_HANDLED
    }
    if(!available_duelers(id))
    {
        client_print_color(id, "%sThere's ^4nobody^1 you can challenge.",CHAT_TAG)
        return PLUGIN_HANDLED
    }
    if(get_next_arena() == -1)
    {
        client_print_color(id, "%s^4Maximum arenas reached.",CHAT_TAG)
        return PLUGIN_HANDLED
    }
    new menu,menuformat[64];
    formatex(menuformat,charsmax(menuformat),"\w[ \rKnifeDuels \w] \dArenas: %d/%d",arenas_count(),total_arenas)
    menu = menu_create( menuformat, "Duel_handler" );
    
    new players[32], pnum, tempid;
    
    new szName[32], szUserId[32],nameu[92],CsTeams:team;
    formatex(nameu,charsmax(nameu), "\yRefresh");
    menu_additem(menu, nameu,"rf_c", 0);
    menu_addblank(menu,0)
    get_players( players, pnum, "c" );
    for ( new e; e<pnum; e++ )
    {
        tempid = players[e]
        team = cs_get_user_team(tempid)
        
        if(tempid != id && team != CS_TEAM_SPECTATOR && team != CS_TEAM_UNASSIGNED)//  && !users_in_same_team(id,tempid))
        {
            get_user_name(tempid, szName, charsmax(szName));
            formatex(szUserId, charsmax(szUserId), "%d", get_user_userid(tempid));
            if(his_offline[tempid])
            {
                formatex(nameu,charsmax(nameu), "\d%s [Offline]", szName);
                menu_additem(menu, nameu, szUserId, 0);
            }
            if(isBlocked[tempid][id])
                           {
                               formatex(nameu,charsmax(nameu), "%s \w[\rBlocked\w]", szName);
                               menu_additem(menu, nameu, szUserId, 0);
                           }
            else
            {
                if(is_in_duel[tempid] == 2)
                {
                    formatex(nameu,charsmax(nameu), "\r%s [Duel]", szName);
                    menu_additem(menu, nameu, szUserId, 0);
                }
                else if(is_in_duel[tempid] == 1)
                {
                    formatex(nameu,charsmax(nameu), "\y%s [Pending]", szName);
                    menu_additem(menu, nameu, szUserId, 0);
                }
                else
                {
                    formatex(nameu,charsmax(nameu), "%s", szName);
                    menu_additem(menu, nameu, szUserId, 0);
                }
            }
        }
    }
    
    menu_display(id, menu, 0 );
    return PLUGIN_HANDLED
}
 
public Duel_handler( id, menu, item )
{
    if ( item == MENU_EXIT )
    {
        menu_destroy( menu );
        return PLUGIN_HANDLED;
    }
    
    new szData[32], szName[64];
    new _access, item_callback;
    menu_item_getinfo( menu, item, _access, szData,charsmax( szData ), szName,charsmax( szName ), item_callback );
    if(equali(szData,"rf_c"))
    {
        menu_destroy( menu );
        duel_players_list(id)
        return PLUGIN_CONTINUE
    }
    new userid = str_to_num( szData );
    //spam_hud(id)
    new enem = find_player("k", userid); // flag "k" : find player from userid
    if (is_user_connected(enem))
    {
        if(his_offline[enem])
        {
            client_print_color(id, "%sYou can't challenge offline players.",CHAT_TAG)
        }
        if(isBlocked[enem][id])
             {
                 client_print_color(id,"%sThis user blocked you!",CHAT_TAG)
             }
        else
        {
            if(!is_in_duel[enem])
            {
                //spam_hud(enem)
                is_in_duel[enem] = 1
                is_in_duel[id] = 1
                his_player_arena_entity[id] = true;
                his_asker[id] = enem
                his_asker[enem] = id
                ask_player(enem)
                client_print_color(0, "%s^4%s^1 has ^3challenged^1 ^4%s^1 for a ^3duel^1!",CHAT_TAG,his_name[id],his_name[enem])
                
                set_task(10.0,"taken_long",id)
            }
            else
            {
                client_print_color(id, "%s^4%s^1 seems to be busy with another duel..",CHAT_TAG,his_name[enem])
            }
        }
    }
    menu_destroy( menu );
    return PLUGIN_CONTINUE;
}
 
public taken_long(id)
{
    if(is_in_duel[id] == 1)
    {
        client_print_color(0, "%s^4%s ^1has taken ^3too long to respond ^1to ^4%s^1's challenge.",CHAT_TAG,his_name[his_asker[id]],his_name[id])
        reset_values(his_asker[id])
        reset_values(id)
    }
}
 
stock available_duelers(asker)
{
    new num;
    num = 0 // just incase...
    for(new id;id < MAXPLAYERS;id++)
    {
        if(is_user_alive(id))
        {
            if(/*!is_in_duel[id] && */id != asker && !is_user_bot(id))
            {
                num++
            }
        }
    }
    return num
}
 
public ask_player(id)
{
    if(!is_user_alive(id))
    {
        return PLUGIN_HANDLED
    }
    new asker_name[32],menu_title[64];
    get_user_name(his_asker[id],asker_name,charsmax(asker_name))
    formatex(menu_title,charsmax(menu_title),"\rAccept Duel \y%s\r %s %s",asker_name,arenas_results(principals[his_asker[id]][swich_arena]),types_results(principals[his_asker[id]][swich_types]))
    new menu
    menu = menu_create( menu_title, "Ask_handler" );
    
         
    
    menu_additem(menu, "Sure!", "user_said_yes", 0);
    menu_additem(menu, "Nope!","user_said_no", 0);
    
    menu_display(id, menu, 0 );
    return PLUGIN_HANDLED
}
 
public Ask_handler( id, menu, item )
{
    if ( item == MENU_EXIT )
    {
        menu_destroy( menu );
        return PLUGIN_HANDLED;
    }
    
    new szData[32], szName[64];
    new _access, item_callback;
    menu_item_getinfo( menu, item, _access, szData,charsmax( szData ), szName,charsmax( szName ), item_callback );
    
    if(equali(szData,"user_said_yes"))
    {
        if(get_next_arena() == -1)
        {
            client_print_color(his_asker[id], "%sMaximum arenas reached.",CHAT_TAG)
            reset_values(his_asker[id])
            reset_values(id)
        }
        else if(is_in_duel[his_asker[id]] == 1)
        {
            manage_battle(id)
            check_teams(id,his_challenger[id])
            begin_the_battle(id,his_challenger[id])
        } else
        {
            client_print_color(id, "%s%s either canceled the duel or chosen someone else to duel.",CHAT_TAG,his_name[his_asker[id]])
            reset_values(his_asker[id])
            reset_values(id)
        }
    }
    else if(equali(szData,"user_said_no"))
    {
        if(is_user_connected(his_asker[id]))
        {
            client_print_color(0, "%s^4%s^3 rejected ^4%s^3's challenge.",CHAT_TAG,his_name[id],his_name[his_asker[id]])
            reset_values(his_asker[id])
            reset_values(id)
        }
        
    }
    menu_destroy( menu );
    return PLUGIN_CONTINUE;
}
 
public Player_Killed(victim, attacker, shouldgib)
{
    if(!is_user_connected(victim))
        return //HAM_IGNORED;
    if(is_user_connected(his_challenger[victim]) && !is_user_connected(attacker))
    {
        if(!check_teams(victim,attacker))
            return //HAM_IGNORED
    }
    if(!is_user_connected(attacker))
        return //HAM_IGNORED
        
    if(attacker == victim)
        return //HAM_IGNORED
    
    if(is_in_duel[attacker] != 2 || is_in_duel[victim] != 2)
        return //HAM_IGNORED
    
    if(his_challenger[victim] == attacker || his_challenger[attacker] == victim )
    {
        //fake_death(attacker,victim)
        his_wins[attacker]++
        rounds[arena_number[attacker]]++
        static ret;
        ExecuteForward(killed_forward, ret, attacker,victim)
        
        if(Head_shot[attacker][victim])
        {
            his_HS[attacker]++
            Head_shot[attacker][victim] = false
        }
        user_silentkill(victim)
        if(rounds[arena_number[attacker]] >= MAX_ROUNDS || his_wins[attacker] >= MAX_KILLS)
        {
            if(!get_non_duelers_alive())
            {
                ExecuteHamB(Ham_CS_RoundRespawn, victim)
                Check_Results(attacker,victim)
                //return HAM_SUPERCEDE
            }
            else
            {
                ExecuteHamB(Ham_CS_RoundRespawn, victim)
                Check_Results(attacker,victim)
            }
        }
        else 
        {
            wait_for_enemy_loop(attacker)
            //client_print_color(attacker, "%s^4Rounds^1:^3%d^4/^3%d^1 | ^4You^1:^3%d^4/^3%d^1 | ^4%s^1:^3%d^4/^3%d^1.",CHAT_TAG,rounds[arena_number[attacker]],MAX_ROUNDS,his_wins[attacker],MAX_KILLS,his_name[victim],his_wins[victim],MAX_KILLS)
            //client_print_color(victim, "%s^4Rounds^1:^3%d^4/^3%d^1 | ^4You^1:^3%d^4/^3%d^1 | ^4%s^1:^3%d^4/^3%d^1.",CHAT_TAG,rounds[arena_number[attacker]],MAX_ROUNDS,his_wins[victim],MAX_KILLS,his_name[attacker],his_wins[attacker],MAX_KILLS)
        }
        Set_Entity_Invisible(victim, 1)
        set_task(0.1,"delay_respawn",victim)
        return //HAM_SUPERCEDE
    }
    return //HAM_IGNORED
}
 
public fake_death(attacker,victim)
{
    message_begin( MSG_ALL, get_user_msgid("DeathMsg"),{0,0,0},0)
    write_byte(attacker)
    write_byte(victim)
    write_byte(0)
    write_string("knife")
    message_end()
}
 
public delay_respawn(id)
{
    if(is_user_connected(id))
    {
        if(!is_user_alive(id))
        {
            ExecuteHamB(Ham_CS_RoundRespawn, id)
        }
        Set_Entity_Invisible(id, 0)
    }
    return PLUGIN_CONTINUE
}
public Check_Results(id,enemy)
{
    reset_teams(id)
    reset_teams(enemy)
    new id_name[64],enemy_name[64];
    get_user_name(id,id_name,charsmax(id_name))
    get_user_name(enemy,enemy_name,charsmax(enemy_name))
    if(his_wins[id] > his_wins[enemy])
    {
        client_print_color(0, "^3[^4Arena: %s^3] ^4%s ^1with ^3%d scores (HS:%d) ^1won against ^4%s ^1with ^3%d scores (HS:%d)",arena_names[arena_number[id]],id_name,his_wins[id],his_HS[id],enemy_name,his_wins[enemy],his_HS[enemy])
        reward_winner(id)
        reward_loser(enemy)
    }
    else if(his_wins[enemy] > his_wins[id])
    {
        client_print_color(0, "^3[^4Arena: %s^3] ^4%s ^1with ^3%d scores (HS:%d) ^1won against ^4%s ^1with ^3%d scores (HS:%d)",arena_names[arena_number[id]],enemy_name,his_wins[enemy],his_HS[enemy],id_name,his_wins[id],his_HS[id])
        reward_winner(enemy)
        reward_loser(id)
    }
    else
    {
        client_print_color(0, "^3[^4Arena: %s^3] ^4%s ^1with ^3%d scores (HS:%d) ^1and ^4%s ^1with ^3%d scores (HS:%d) ^1ended in a ^4draw match.",arena_names[arena_number[id]],id_name,his_wins[id],his_HS[id],enemy_name,his_wins[enemy],his_HS[enemy])
        if(SOUNDS_ENABLED)
        {
            client_cmd(id,"spk ^"%s^"",DUEL_SOUNDS[2])
            client_cmd(enemy,"spk ^"%s^"",DUEL_SOUNDS[2])
        }
        if(his_wins[id] == his_wins[enemy])
        {
            user_kill(id,1)
            user_kill(enemy,1)
        }
    }
    //client_print_color(0, "%s^3Headshots: ^4%s^1:^3%d ^4%s^1:^3%d^1.",CHAT_TAG,id_name,his_HS[id],enemy_name,his_HS[enemy])
    if(arena_number[id] == arena_number[enemy])
        remove_the_arena(arena_number[id] +ARENA_CODE)
    back_to_the_spawn(id)
    back_to_the_spawn(enemy)
    reset_values(enemy)
    reset_values(id)
    
}
 
public back_to_the_spawn(id)
{
    if(is_user_alive(id))
    {
        entity_set_origin(id,his_original_spawn[id])
        Set_Entity_Invisible(id, 0)
        set_user_health(id,map_default_hp)
    }
    set_user_armor(id,0)
    set_user_godmode(id, 0)
}
 
 
 
public manage_battle(id)
{
    is_in_duel[id] = 2
    his_challenger[id] = his_asker[id]
    his_challenger[his_challenger[id]] = id
    is_in_duel[his_challenger[id]] = 2
    his_asker[id] = 0
    his_wins[id] = 0
    his_wins[his_challenger[id]] = 0
    new aren_code = get_next_arena()
    arena_number[id] = aren_code
    arena_number[his_challenger[id]] = aren_code
    rounds[aren_code] = 0
    new CsTeams:teamid,CsTeams:teamenemy;
    teamid = cs_get_user_team(id)
    teamenemy = cs_get_user_team(his_challenger[id])
    if(teamid == CS_TEAM_T)
    {
        his_previous_team[id] = 2
    }
    else if(teamid == CS_TEAM_CT)
    {
        his_previous_team[id] = 1
    }
    else his_previous_team[id] = 0
    
    if(teamenemy == CS_TEAM_T)
    {
        his_previous_team[his_challenger[id]] = 2
    }
    else if(teamenemy == CS_TEAM_CT)
    {
        his_previous_team[his_challenger[id]] = 1
    }
    else his_previous_team[his_challenger[id]] = 0
    start_build(his_challenger[id])
    if(SOUNDS_ENABLED)
    {
        client_cmd(id,"spk ^"%s^"",DUEL_SOUNDS[4])
        client_cmd(his_challenger[id],"spk ^"%s^"",DUEL_SOUNDS[4])
    }
    
         if(his_arena[id] == 2)
         {
             his_arena[his_challenger[id]] = 2;
             set_user_health(id,100)
             set_user_health(his_challenger[id],100)
         }
    else
    {
        set_user_health(his_challenger[id],map_default_hp)
        set_user_health(id,map_default_hp)
    }
    
    battle_timer(id)
    battle_timer(his_challenger[id])
    hud_displayer(id)
    hud_displayer(his_challenger[id])
 
    CopyWeaponSettings(id)
    CopyWeaponSettings(his_challenger[id])
    
    strip_user_weapons(id)
    strip_user_weapons(his_challenger[id])
    
    give_item(id, WeaponModel[Weapons_Settings[id]]);
    give_item(his_challenger[id], WeaponModel[Weapons_Settings[his_challenger[id]]]);
    
    client_print_color(0, "%s^4%s^3 accepted ^4%s^3's challenge!",CHAT_TAG,his_name[id],his_name[his_challenger[id]])
}
 
public begin_the_battle(id,enemy)
{
    start_new_round(id,enemy)
}
 
public start_new_round(id,enemy)
{
    his_timer[id] = 0
    his_timer[enemy] = 0
    is_frozen[id] = 1
    is_frozen[enemy] = 1
    his_countdown[id] = MAX_COUNTDOWN
    his_countdown[enemy] = MAX_COUNTDOWN
    countdown(id)
    countdown(enemy)
}
 
public countdown(id)
{
    new name[64],his_name[64];
    
    get_user_name(id,name,charsmax(name))
    get_user_name(his_challenger[id],his_name,charsmax(his_name))
 
    if(is_user_connected(id))
    {
        his_countdown[id]--
        if(0 >= his_countdown[id])
        {
            is_frozen[id] = 0
            unfreeze_player(id)
            if(SOUNDS_ENABLED)
                client_cmd(id,"spk ^"%s^"",DUEL_SOUNDS[6])
            client_print(id,print_center,"%s    [%d] VS [%d]   %s",name,his_wins[id],his_wins[his_challenger[id]],his_name)
            return PLUGIN_HANDLED
        }
        else
        {
            freeze_player(id)
            if(SOUNDS_ENABLED)
                client_cmd(id,"spk ^"%s^"",DUEL_SOUNDS[5])
            client_print(id,print_center,"%d",his_countdown[id])
            if(!is_frozen[id]) // we prevent it from spamming
                is_frozen[id] = 1
        }
        set_task(1.0,"countdown",id)
    }
    return PLUGIN_CONTINUE
}
 
public reset_teams(id)
{
    if(his_previous_team[id] == 1)
    {
        cs_set_user_team(id,CS_TEAM_CT)
    }
    else if(his_previous_team[id] == 2)
    {
        cs_set_user_team(id,CS_TEAM_T)
    }
    return PLUGIN_CONTINUE
}
 
public check_teams(id,enemy)
{
    new CsTeams:teamid,CsTeams:teamenemy;
    teamid = cs_get_user_team(id)
    teamenemy = cs_get_user_team(enemy)
    if(!users_in_same_team(id,enemy) && !is_in_false_team(id) && !is_in_false_team(enemy))
        return PLUGIN_HANDLED
    if(teamid == CS_TEAM_CT && teamenemy == CS_TEAM_CT )
    {
        cs_set_user_team(id,CS_TEAM_T)
    } else if(teamid == CS_TEAM_T && teamenemy == CS_TEAM_T)
    {
        cs_set_user_team(id,CS_TEAM_CT)
    }
    else
    {
        Check_Results(id,enemy)
        return PLUGIN_CONTINUE
    }
    return PLUGIN_HANDLED
}
stock is_in_false_team(id)
{
    if(cs_get_user_team(id) == CS_TEAM_SPECTATOR || cs_get_user_team(id) == CS_TEAM_UNASSIGNED)
        return PLUGIN_HANDLED
    return PLUGIN_CONTINUE
}
stock users_in_same_team(id,enemy)
{
    if(cs_get_user_team(id) == cs_get_user_team(enemy))
        return PLUGIN_HANDLED
    return PLUGIN_CONTINUE
}
 
stock get_next_arena()
{
    next_empty_arena = 0
    for(new id;id < MAXPLAYERS;id++)
    {
        if(is_user_connected(id))
        {
            if(arena_number[id] == next_empty_arena)
            {
                next_empty_arena++
                if(next_empty_arena > total_arenas)
                    return -1
            }
        }
    }
    if(next_empty_arena > total_arenas)
    {
        return -1
    }
    return next_empty_arena
}
 
stock reset_values(id)
{
    his_HS[id] = 0
    rounds[arena_number[id]] = 0
    is_in_duel[id] = 0
    his_challenger[id] = 0
    his_asker[id] = 0
    arena_number[id] = 0
    his_wins[id] = 0
    got_spawn[id] = 0
    his_timer[id] = 0
    prevent_bad_spawn[id] = 0
    his_arena[id] = 0
    his_types[id] = 0
    Weapons_Settings[id] = 0
    set_pev(id, pev_groupinfo, GROUP_PLAYER) 
}
 
public freeze_player(id)
{
    set_user_maxspeed(id,1.0)
}
 
public unfreeze_player(id)
{
    set_user_maxspeed(id,250.0)
}
 
 
 
public wait_for_enemy_loop(id)
{
    if(is_user_connected(id))
    {
        if(is_in_duel[id] == 2)
        {
            if(is_user_connected(his_challenger[id]))
            {
                if(is_in_duel[his_challenger[id]] == 2)
                {
                    if(is_user_alive(his_challenger[id]))
                    {
                        begin_the_battle(id,his_challenger[id])
                        return PLUGIN_HANDLED
                    }
                    set_task(0.1,"wait_for_enemy_loop",id)
                }
            }
        }
    }
    return PLUGIN_CONTINUE
}
 
public hud_displayer(id)
{
    if(is_user_connected(id))
    {
        if(is_in_duel[id] == 2 && is_user_connected(his_challenger[id]))
        {
            check_is_duelant_to_platform(id);
            check_is_duelant_to_platform(his_challenger[id]);
            
            set_task(1.0,"hud_displayer",id)
        }
    }
}
 
stock Set_Entity_Invisible(ent, Invisible = 1)
{
    if(!pev_valid(ent))
        return
    set_pev(ent, pev_effects, Invisible == 0 ? pev(ent, pev_effects) & ~EF_NODRAW : pev(ent, pev_effects) | EF_NODRAW)
}
 
stock client_print_color(const id, const input[], any:...)  
{  
    new count = 1, players[32];  
    static msg[191];  
    vformat(msg, 190, input, 3);
    replace_all(msg, 190, "!g", "^x04"); // Green Color  
    replace_all(msg, 190, "!y", "^x01"); // Default Color  
    replace_all(msg, 190, "!t", "^x03"); // Team Color  
    if (id) players[0] = id; else get_players(players, count, "ch");  
    {  
        for (new i = 0; i < count; i++)  
        {  
            if (is_user_connected(players[i]))  
            {  
                message_begin(MSG_ONE_UNRELIABLE, get_user_msgid("SayText"), _, players[i]);  
                write_byte(players[i]);  
                write_string(msg);  
                message_end();  
            }  
        }  
    }  
}
 
public check_is_duelant_to_platform(id)
{
    new iEnt, iTrace, Float: fOriginStart[3], Float: fOriginEnd[3];
    new ent_code = arena_number[id]+ARENA_CODE
    
    entity_get_vector(id, EV_VEC_origin, fOriginStart);
    fOriginEnd = fOriginStart; fOriginEnd[2] -= 500;
    iTrace = create_tr2();
    engfunc(EngFunc_TraceLine, fOriginStart, fOriginEnd, 0, id, iTrace);
    iEnt = get_tr2(iTrace, TR_pHit);
    
    if(!pev_valid(iEnt) || entity_get_int(iEnt, EV_INT_iuser1) != ent_code)
    {
             prevent_bad_spawn[id] +=1;
             spawn_back(id)
             client_print(id,print_center,"Stay On The Area [%d / 10]",prevent_bad_spawn[id])
            
             if(prevent_bad_spawn[id] == 10) 
             {
                 end_his_duel(id)
             }
    }
}
 
////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// Invsible Arena & Players  ///////////////////////////////////////
 
public OnCBasePlayer_Spawn_Post(id)
{
    if( is_user_alive(id) )
    {
        set_pev(id, pev_groupinfo, GROUP_ENTITY | GROUP_PLAYER);
    }
    if(is_user_alive(id) && his_arena[id] == 2)
    {
        his_arena[his_challenger[id]] = 2;
        set_user_health(id,100)
        set_user_health(his_challenger[id],100)
    }
} 
 
public ForwardAddToFullPack(ES,e,Ent,Host,HostFlags,Player,pSet)
{
    static arenas_ent = -1
 
    while((arenas_ent=engfunc(EngFunc_FindEntityByString,arenas_ent,"classname",ARENA_ENT_NAME)))   
    {           
    if(Player && is_user_alive(Host) && is_user_alive(Ent) && ((is_in_duel[Ent] != is_in_duel[Host]) || (!is_in_duel[Host] && is_in_duel[Ent])))
    {
        set_es(ES,ES_Solid,SOLID_NOT)
        set_es(ES,ES_RenderMode,kRenderTransAlpha)
        set_es(ES,ES_RenderAmt,clamp(get_pcvar_num(p_Transparency),0,255))
    }
   }
}
 
public ForwardPlayerPreThink(id)
{
    for(new Count = 1;Count <= MAXPLAYERS;Count++)
    {
        if(!is_user_connected(Count) || Count == id || (!his_challenger[id] && !his_challenger[Count]) || his_challenger[id] == Count)
            continue
        
        g_PlayerSolid[Count] = pev(Count,pev_solid)
        set_pev(Count,pev_solid,SOLID_NOT)
        
        set_user_footsteps ( Count, 0 )
    }
    
    return FMRES_IGNORED
}
 
public ForwardPlayerPostThink(id)
{
    for(new Count;Count < MAXPLAYERS;Count++)
    {
        if(!is_user_connected(Count) || Count == id || (!his_challenger[id] && !his_challenger[Count]) || his_challenger[id] == Count)
            continue
        
        set_pev(Count,pev_solid,g_PlayerSolid[Count])
    }
    
    return FMRES_IGNORED
}
 
public ForwardTraceLine(Float:v1[3],Float:v2[3],NoMonsters,SkipEnt,Ptr)
{
    if(!is_user_alive(SkipEnt))
        return FMRES_IGNORED
    
    new Ptr2
    engfunc(EngFunc_TraceLine,v1,v2,NoMonsters,SkipEnt,Ptr2)
    new Hit = get_tr2(0,TR_pHit)
    if(is_user_alive(Hit) && ((Hit != his_challenger[SkipEnt] && his_challenger[SkipEnt]) || (!his_challenger[SkipEnt] && his_challenger[Hit])))
        set_tr(TR_flFraction,1.0)
    
    return FMRES_IGNORED
}
 
public ForwardTraceHull(Float:v1[3],Float:v2[3],NoMonsters,Hull,SkipEnt,Ptr)
{
    if(!is_user_alive(SkipEnt))
        return FMRES_IGNORED
    
    new Ptr2
    engfunc(EngFunc_TraceHull,v1,v2,NoMonsters,Hull,SkipEnt,Ptr2)
    new Hit = get_tr2(0,TR_pHit)
    if(is_user_alive(Hit) && ((Hit != his_challenger[SkipEnt] && his_challenger[SkipEnt]) || (!his_challenger[SkipEnt] && his_challenger[Hit])))
        set_tr(TR_flFraction,1.0)
    
    return FMRES_IGNORED    
}
 
public ForwardAddToFullPackPost( es_handle, e, ent, host, hostflags, player, pset )
{
    if( his_arena_entity[ent] )
    {
        if(is_in_duel[host] == 2)
        {
                set_pev(host, pev_groupinfo, GROUP_ENTITY)
        }
        else if(arena_selected == 1)
        {
            //set_es( es_handle, ES_Effects, EF_NODRAW );
            set_pev(host, pev_groupinfo, GROUP_PLAYER) 
        }
    }
}
public client_PreThink(id)
{
    if(is_user_bot(id))
    {
        set_pev(id, pev_groupinfo, GROUP_PLAYER) 
    }
    
    if(his_player_arena_entity[id])
    {
        new ent = engfunc( EngFunc_FindEntityByString, -1, "classname", "entity_arena" );
        while( ent )
        {
            his_arena_entity[ent] = true;
 
            ent = engfunc( EngFunc_FindEntityByString, ent, "classname", "entity_arena" );
        
            his_player_arena_entity[id] = false;
        }
    }
}
 
///////////////////////////////////  bttale types  /////////////////////////////////////////////////
 
public fw_PlayerPreThink( id )
{
    static btn
    
    if(is_in_duel[id] == 2)
    {
 
        if(his_types[id] == 2)
        {
            btn = pev(id, pev_button)
            
            if(btn & IN_ATTACK)
            {
                set_pev(id,pev_button,(btn & ~IN_ATTACK) | IN_ATTACK2)
            }
        }
        else if(his_types[id] == 1)
        {
            btn = pev(id, pev_button)
            
            if(btn & IN_ATTACK2)
            {
                set_pev(id,pev_button,(btn & ~IN_ATTACK2) | IN_ATTACK)
            }
        }
    }
    return FMRES_IGNORED
}
 
 
public Forward_TraceAttack(id, attacker, Float:dmg, Float:dir[3], tr, dmgbit)
{
    if(id != attacker && get_tr2(tr, TR_iHitgroup) != HIT_HEAD && get_pcvar_num(display_hud))
    {
        if(1 <= attacker <= MAXPLAYERS)
        {
            if(is_in_duel[id] == 2 && his_types[id] == 3)
            {
                if(!get_pcvar_num(display_hud) && get_user_weapon(attacker) == CSW_KNIFE)
                {
                    return HAM_IGNORED;
                }
                
                return HAM_SUPERCEDE;
            }
        }
    }
    
    return HAM_IGNORED;
}
 
public Rush_Non_Stop(id)
{
    if(is_in_duel[id] == 2 && his_types[id] == 4)
    {
        if(get_user_team(id) == 1)
        {
            fVelocity[0] = 250.0;
            fVelocity[1] = 0.0;
            fVelocity[2] = 0.0;
            
            set_pev( id, pev_velocity, fVelocity )
        }
        if(get_user_team(id) == 2)
        {
            fVelocity[0] = -250.0;
            fVelocity[1] = 0.0;
            fVelocity[2] = 0.0;
            
            set_pev( id, pev_velocity, fVelocity )
        }
    }
}
 
///////////////////////////////  Block Player Menu  ////////////////////////////////////////////////
 
public GetName( id )
{
    new name[32]
    
    get_user_name(id, name, charsmax(name))
    return name
}
 
public BlockMenu( id )
{
    new pl[32], num 
    get_players(pl, num,"ch")
    static menuid, menu[128], buffer[2]
    
    if(!available_duelers(id))
    {
        client_print_color(id, "%sThere's ^4nobody^1 to block.",CHAT_TAG)
        return PLUGIN_HANDLED
    }
    
    
    menuid = menu_create("Block Players Menu", "BlockMenuHandler")
    buffer[1] = 0
    
    for(new i = 0; i < num; i++)
    {
        if(id == pl[i]) continue
        formatex(menu, charsmax(menu), "%s %s", GetName(pl[i]), isBlocked[id][pl[i]]? "\r[BLOCKED]":"")
        buffer[0] = pl[i]
        menu_additem(menuid, menu, buffer)
    }
    menu_display(id, menuid, 0)
    return PLUGIN_HANDLED
}
public BlockMenuHandler( id, menuid, item )
{
    if(!is_user_connected(id) || item == MENU_EXIT)
    {
        menu_destroy(menuid)
        return PLUGIN_HANDLED
    }
    new dummy, buffer[2], playerid
    menu_item_getinfo(menuid, item, dummy, buffer, charsmax(buffer), _, _, dummy )
    playerid = buffer[0]
    isBlocked[id][playerid] = !isBlocked[id][playerid]
    client_print_color(id, "%s Player '%s' %sblocked from sending you requests", CHAT_TAG, GetName(playerid), isBlocked[id][playerid]? "":"un")
    BlockMenu( id )
    return PLUGIN_HANDLED
}
 
 
 
public CopyWeaponSettings(id)
{
    if(Weapons_Settings[id] == 0)
    {
        Weapons_Settings[his_challenger[id]] = 0
    }
    if(Weapons_Settings[id] == 1)
    {
        Weapons_Settings[his_challenger[id]] = 1
    }
    if(Weapons_Settings[id] == 2)
    {                                                                                
        Weapons_Settings[his_challenger[id]] = 2
    }
    if(Weapons_Settings[id] == 3)
    {
        Weapons_Settings[his_challenger[id]] = 3
    }
    if(Weapons_Settings[id] == 4)
    {
        Weapons_Settings[his_challenger[id]] = 4
    }
    if(Weapons_Settings[id] == 5)
    {
        Weapons_Settings[his_challenger[id]] = 5
    }
    if(Weapons_Settings[id] == 6)
    {
        Weapons_Settings[his_challenger[id]] = 6
    }
    if(Weapons_Settings[id] == 7)
    {
        Weapons_Settings[his_challenger[id]] = 7
    }
    if(Weapons_Settings[id] == 8)
    {
        Weapons_Settings[his_challenger[id]] = 8
    }
    if(Weapons_Settings[id] == 9)
    {
        Weapons_Settings[his_challenger[id]] = 9
    }
    if(Weapons_Settings[id] == 10)
    {
        Weapons_Settings[his_challenger[id]] = 10
    }
    if(Weapons_Settings[id] == 11)
    {
        Weapons_Settings[his_challenger[id]] = 11
    }
    if(Weapons_Settings[id] == 12)
    {
        Weapons_Settings[his_challenger[id]] = 12
    }
    if(Weapons_Settings[id] == 13)
    {
        Weapons_Settings[his_challenger[id]] = 13
    }
    if(Weapons_Settings[id] == 14)
    {
        Weapons_Settings[his_challenger[id]] = 14
    }
    if(Weapons_Settings[id] == 15)
    {
        Weapons_Settings[his_challenger[id]] = 15
    }
    if(Weapons_Settings[id] == 16)
    {
        Weapons_Settings[his_challenger[id]] = 16
    }
    if(Weapons_Settings[id] == 17)
    {
        Weapons_Settings[his_challenger[id]] = 17
    }
    if(Weapons_Settings[id] == 18)
    {
        Weapons_Settings[his_challenger[id]] = 18
    }
}
 
public HAM_Touch_Weapon(ent, id) 
{
    if(is_user_alive(id) && !(get_pdata_cbase(ent, 39, 4) > 0))
        return HAM_SUPERCEDE
    return HAM_IGNORED
}
 
public Fw_SetModel(entity, const model[])
{
        set_task(1.0, "RemoveItems", entity)
            return;
}
 
public RemoveItems(entity)
{
    static Class[10]
    
    if(!pev_valid(entity))
        return;
    
    pev(entity, pev_classname, Class, sizeof Class - 1)
        
    if (equal(Class, "weaponbox"))
    {
        set_pev(entity, pev_nextthink, get_gametime() + 1.0)
        return;
    }
}
 
public block_moving(id, weapons, cd)
{
    if(his_types[id] == 4)
    {
        set_cd(cd, CD_flNextAttack, 0.1)
   
        if((entity_get_int(id, EV_INT_button) & (IN_MOVELEFT | IN_MOVERIGHT | IN_BACK )))
            set_cd(cd, CD_MaxSpeed, 0.1)
    }
}
 
public fwd_Player_PreThink(id)
{
    if(his_types[id] == 4)
    {
        set_pev(id, pev_oldbuttons, pev(id, pev_oldbuttons)|IN_JUMP|IN_DUCK);
    }
}
 
public event_curweapon(id)
{
    if(his_arena[id] == 2)
    {
    new weaponID= read_data(2)
    if(weaponID==CSW_C4 || weaponID==CSW_KNIFE || weaponID==CSW_HEGRENADE || weaponID==CSW_SMOKEGRENADE || weaponID==CSW_FLASHBANG)
        return PLUGIN_CONTINUE;
    
    if(cs_get_user_bpammo(id, weaponID)!=CSW_MAXAMMO[weaponID])
        cs_set_user_bpammo(id, weaponID, CSW_MAXAMMO[weaponID])
   }
   return PLUGIN_CONTINUE;
 
}
///////////////////////////////////////  RANK  /////////////////////////////////////////////////////
 
////////////////////////////////////////////  MENU  ////////////////////////////////////////////////
public Rank_Menu(id)
{
    new menu = menu_create("\r[\y Rank & Top Menu \r]\w By raizo","Rank_Menu_Handled")
 
    formatex(szTmp,charsmax(szTmp),"Rank");
    menu_additem(menu,szTmp,"1")
 
    formatex(szTmp,charsmax(szTmp),"Top");
    menu_additem(menu,szTmp,"2")
    
    menu_display(id,menu)
 
    return PLUGIN_HANDLED;
}
 
public Rank_Menu_Handled(id,menu,item)
{
    if(item == MENU_EXIT)
    {
        menu_destroy(menu);
 
        return PLUGIN_HANDLED;
    }
 
    new data[3], iName[64]
    new access, callback;
    menu_item_getinfo(menu, item, access, data,2, iName, 63, callback);
    new key = str_to_num(data)
 
    switch(key)
    {
        case 1:
        {
            CmdRank(id)
            return PLUGIN_HANDLED;
        }
        case 2:
        {
            CmdTop(id)
            return PLUGIN_HANDLED;
        }
    }
    menu_destroy(menu);
 
    return PLUGIN_HANDLED;
}
 
 
public CmdReset( )
{
    fvault_clear( g_szVaultName );
 
    server_print( "[Knife Duel] Rank have been reset !" );
 
    log_amx( "[Knife Duel] Rank have been reset !" );
 
    return PLUGIN_HANDLED;
}
 
public CmdRank( iPlayer )
{
    new Array:aRankData;
    new iTotal = GetPlayerRanks( aRankData );
 
    new iRank;
    new eRankData[ RankData ];
 
    if( iTotal )
    {
    new szPlayerSteamID[ 35 ];
    get_user_authid( iPlayer, szPlayerSteamID, charsmax( szPlayerSteamID ) );
    
    for( new i = 0; i < iTotal; i++ )
    {
        ArrayGetArray( aRankData, i, eRankData );
        
        if( equal( szPlayerSteamID, eRankData[ Rank_SteamID ] ) )
        {
            iRank = i + 1;
            break;
        }
    }
    }
 
    if( iRank )
    {
    client_print( iPlayer, print_chat, "[Knife Duel] You are ranked %i of %i with %i kill%s!", iRank, iTotal, eRankData[ Rank_Kills ], ( eRankData[ Rank_Kills ] == 1 ) ? "" : "s" );
    }
    else
    {
    client_print( iPlayer, print_chat, "[Knife Duel] You are not ranked because you have not killed anyone!" );
    }
 
    ArrayDestroy( aRankData );
    
    Principal_Menu(iPlayer)
}
 
public CmdTop( iPlayer )
{
    new Array:aRankData;
    new iTotal = max( 0, min( GetPlayerRanks( aRankData ), get_pcvar_num( pCvar_Top ) ) );
 
    if( iTotal )
    {
    static szMOTD[ 2500 ], iDefaultLen;
    if( !iDefaultLen )
    {
        iDefaultLen = add( szMOTD, charsmax( szMOTD ),
        "<html><style>\
        body{background:#040404;font-family:Verdana, Arial, Sans-Serif;font-size:7pt;}\
        .t{color:#808080;text-align:left; }\
        #h{background: #222 url('http://limmudny.org/wp-content/uploads/2014/09/PageTitleBackground2-900x100.jpg') repeat-x;color:#000;font-weight:bold;}\
            #p{color:#D41313;}\
            #n{color:#fff;}\
            </style><body>\
            <table cellspacing=0 width=100% class=t>")
            
            add(szMOTD, charsmax(szMOTD),
            "<tr><td id=h width=7%>Nr:</td>\
            <td id=h>Nick</td>\
            <td id=h>Kills</td></tr>")
            
            iDefaultLen = strlen(szMOTD)
        }
        
        new iLen = iDefaultLen;
        
        new eRankData[ RankData ];
        
        new szFixedName[ 128 ];
        
        for( new i = 0; i < iTotal; i++ )
        {
            ArrayGetArray( aRankData, i, eRankData );
            
            copy( szFixedName, charsmax( szFixedName ), eRankData[ Rank_Name ] );
            
            MakeNameMOTDSafe( szFixedName, 31 );
            
            iLen += formatex( szMOTD[ iLen ], charsmax( szMOTD ) - iLen, "<tr><td>%i</td><td>%s</td><td>%i</td></tr>", ( i + 1 ), szFixedName, eRankData[ Rank_Kills ] );
        }
        
        copy( szMOTD[ iLen ], charsmax( szMOTD ) - iLen, "</tbody></table></body>" );
        
        show_motd( iPlayer, szMOTD, "Knife Duel Top" );
    }
    else
    {
        client_print( iPlayer, print_chat, "* No players have been put on the top!" );
    }
    
    ArrayDestroy( aRankData );
    Principal_Menu(iPlayer)
}
 
 
public fw_PlayerKilled(iVictim, iKiller)  
{
    if (iVictim == iKiller || !is_user_alive(iKiller))
        return
        
        new szName[ 32 ], szSteamID[ 35 ];
        get_user_authid( iKiller, szSteamID, charsmax( szSteamID ) );
        
        new szKills[ 48 ], iKills;
        
        if( fvault_get_data( g_szVaultName, szSteamID, szKills, charsmax( szKills ) ) )
        {
            strbreak( szKills, szKills, charsmax( szKills ), szName, charsmax( szName ) );
            
            iKills = str_to_num( szKills );
        }
        if(is_in_duel[iKiller] == 2)
        {
            iKills++;
            
            get_user_name( iKiller, szName ,charsmax( szName ) );
            
            formatex( szKills, charsmax( szKills ), "%i %s", iKills, szName );
            
            fvault_set_data( g_szVaultName, szSteamID, szKills );
        }
        
    }
    
    GetPlayerRanks( &Array:aRankData )
{
    aRankData = ArrayCreate( RankData );
    new iTotal;
    
    new eRankData[ RankData ];
    
    new szFileName[ 128 ];
    _FormatVaultName( g_szVaultName, szFileName, charsmax( szFileName ) );
    
    new iFile = fopen( szFileName, "rt" );
    
    if( !iFile )
    {
        return iTotal;
    }
    
    new szFileData[ 128 ];
    new szKills[ 48 ];
    
    while( !feof( iFile ) )
    {
        fgets( iFile, szFileData, charsmax( szFileData ) );
        trim( szFileData );
        
        if( !szFileData[ 0 ] )
        {
            continue;
        }
        
        parse( szFileData, eRankData[ Rank_SteamID ], charsmax( eRankData[ Rank_SteamID ] ), szKills, charsmax( szKills ) );
        strbreak( szKills, szKills, charsmax( szKills ), eRankData[ Rank_Name ], charsmax( eRankData[ Rank_Name ] ) );
        eRankData[ Rank_Kills ] = str_to_num( szKills );
        
        ArrayPushArray( aRankData, eRankData );
        
        iTotal++;
    }
    
    fclose( iFile );
    
    ArraySort( aRankData, "SortData" );
    
    return iTotal;
}
 
public SortData( Array:aData, iIndex1, iIndex2, const iSortData[ ], iSortDataSize )
{
    new eData1[ RankData ], eData2[ RankData ];
    ArrayGetArray( aData, iIndex1, eData1 );
    ArrayGetArray( aData, iIndex2, eData2 );
    
    return clamp( ( eData2[ Rank_Kills ] - eData1[ Rank_Kills ] ), -1, 1 );
}
 
stock MakeNameMOTDSafe( szName[ 128 ], iMaxChars )
{
    szName[ 32 ] = 0;
    
    replace_all( szName, 127, "&", "&amp;" );
    replace_all( szName, 127, "<", "&lt;" );
    replace_all( szName, 127, ">", "&gt;" );
    replace_all( szName, 127, "^"", "&quot;" );
    
    if( iMaxChars > 128 ) return;
    
    new iLast;
    for( new i = 0; i < 128 && szName[ i ]; )
    {
        if( szName[ i ] == '&' )
        {
            if( equal( szName[ i ], "&amp;", 5 ) )
            {
                i += 4;
            }
            else if( equal( szName[ i ], "&quot;", 6 ) )
            {
                i += 5;
            }
            else if( equal( szName[ i ], "&lt;", 4 ) || equal( szName[ i ], "&gt;", 4 ) )
            {
                i += 3;
            }
        }
        
        if( ++i > iMaxChars )
        {
            break;
        }
        
        iLast = i;
    }
    
    szName[ iLast ] = 0;
}